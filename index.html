<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cloudflare BBS</title>
  <style>
    /* (CSSは変更なし) */
    :root {
      --font-classic: 'MS PGothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
      --font-modern: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans CJK JP', 'Noto Sans JP', sans-serif;
    }

    body[data-theme="classic"] {
      --font-family: var(--font-classic);
      --bg-color: #efefef;
      --main-bg-color: #fff;
      --text-color: #333;
      --header-bg-color: #ddd;
      --border-color: #ccc;
      --accent-color: #99c;
      --link-color: #007bff;
      --link-hover-color: #0056b3;
      --post-name-color: #006400;
      --post-meta-color: #555;
      --post-border-color: #eee;
      --thread-hover-bg: #f0f8ff;
      --card-radius: 0px;
      --card-shadow: none;
    }

    body[data-theme="modern"] {
      --font-family: var(--font-modern);
      --bg-color: #f4f7f9;
      --main-bg-color: #ffffff;
      --text-color: #2c3e50;
      --header-bg-color: #ffffff;
      --border-color: #e0e6ed;
      --accent-color: #3498db;
      --link-color: #3498db;
      --link-hover-color: #2980b9;
      --post-name-color: #27ae60;
      --post-meta-color: #7f8c8d;
      --post-border-color: transparent;
      --thread-hover-bg: #ecf5ff;
      --card-radius: 8px;
      --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }
    
    body { 
      font-family: var(--font-family); 
      background-color: var(--bg-color); 
      color: var(--text-color); 
      margin: 0;
      transition: background-color 0.2s, color 0.2s;
    }
    header { 
      background-color: var(--header-bg-color); 
      padding: 10px; 
      text-align: center; 
      border-bottom: 1px solid var(--border-color);
      box-shadow: var(--card-shadow);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    main { 
      max-width: 800px; 
      margin: 20px auto; 
      background-color: var(--main-bg-color); 
      padding: 20px; 
      border: 1px solid var(--border-color);
      border-radius: var(--card-radius);
    }
    h2, h3 { 
      border-bottom: 2px solid var(--accent-color); 
      padding-bottom: 5px;
    }
    form { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
    input, textarea, select { 
      padding: 10px; 
      border: 1px solid var(--border-color); 
      border-radius: 4px; 
      font-family: inherit; 
      font-size: 1em;
      background-color: var(--bg-color);
      color: var(--text-color);
    }
    input:focus, textarea:focus, select:focus {
        outline: none;
        border-color: var(--link-color);
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }
    button { 
      padding: 10px; 
      background-color: var(--link-color); 
      color: white; 
      border: none; 
      cursor: pointer; 
      border-radius: 4px;
      font-size: 1em;
      font-weight: bold;
      transition: background-color 0.2s;
    }
    button:hover { background-color: var(--link-hover-color); }
    button:disabled { background-color: #6c757d; cursor: not-allowed; }
    
    .theme-switcher { margin-bottom: 10px; text-align: right; }
    .theme-switcher button {
      padding: 5px 10px;
      font-size: 0.8em;
      margin-left: 5px;
      background-color: #ccc;
      color: #333;
      font-weight: normal;
    }
    .theme-switcher button.active {
      background-color: var(--link-color);
      color: white;
    }

    .list-item, #thread-list .thread-item { 
      cursor: pointer; 
      padding: 10px; 
      border-bottom: 1px dotted var(--border-color); 
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      transition: background-color 0.2s;
      text-decoration: none;
      color: inherit;
    }
    .list-item:hover, #thread-list .thread-item:hover { background-color: var(--thread-hover-bg); }
    .thread-details { flex-grow: 1; }
    .thread-meta { font-size: 0.8em; color: #666; text-align: right; white-space: nowrap; }
    
    .post { 
      margin-bottom: 15px; 
      padding-left: 10px; 
      border-left: 3px solid var(--post-border-color); 
    }
    .post-header { font-size: 0.9em; color: var(--post-name-color); font-weight: bold; }
    .post-header .post-date { color: var(--post-meta-color); font-weight: normal; margin-left: 10px; }
    .post-body { margin-left: 1em; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; }
    .post-number { cursor: pointer; text-decoration: underline; }
    .bookmark-icon { margin-left: 5px; cursor: pointer; color: var(--accent-color); font-style: normal; }

    
    body[data-theme="modern"] .post {
      border-left: none;
      padding: 15px;
      background-color: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 6px;
    }
    body[data-theme="modern"] .post-body {
        margin-left: 0;
    }
    
    .back-button, #pagination-container button { margin-bottom: 15px; }
    #pagination-container { text-align: center; }

    .view { display: none; } /* Helper class for views */

    .bookmark-controls { display: flex; justify-content: space-between; padding: 10px 0; border-top: 1px solid var(--border-color); margin-top: 15px; }
    .bookmark-item { border-bottom: 1px dotted var(--border-color); padding: 10px; }
    .bookmark-item .post-body { margin-left: 0; font-size: 0.9em; max-height: 3.2em; overflow: hidden; }
    .bookmark-delete-btn { font-size: 0.8em; padding: 2px 6px; background-color: #dc3545; }

    /* --- Modal Styles --- */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    .modal-content {
        background-color: var(--main-bg-color);
        padding: 20px;
        border-radius: var(--card-radius);
        width: 90%;
        max-width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
    }
    .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 1.5em;
        line-height: 1;
        background: none;
        border: none;
        color: var(--text-color);
    }
  </style>
</head>
<body data-theme="classic">

  <header>
    <h1><a href="/" style="text-decoration: none; color: inherit;">Cloudflare BBS</a></h1>
  </header>

  <main>
    <div id="auth-controls" style="text-align: right; margin-bottom: 10px;">
        <span id="user-display"></span>
        <button id="login-btn" onclick="login()">Googleでログイン</button>
        <button id="logout-btn" onclick="logout()" style="display:none;">ログアウト</button>
    </div>
    <div class="theme-switcher">
        <button data-theme="classic">クラシック</button>
        <button data-theme="modern">モダン</button>
    </div>

    <!-- ホーム（ジャンル一覧）ビュー -->
    <div id="home-view" class="view">
        <h2>ジャンル一覧</h2>
        <div id="genre-list"></div>
    </div>
    
    <!-- スレッド一覧ビュー -->
    <div id="thread-list-view" class="view">
      <button class="back-button" id="back-to-home-btn">&laquo; ジャンル一覧に戻る</button>
      <h2 id="thread-list-title"></h2>
      <div id="thread-list"></div>
      <hr>
      <h3>新しいスレッドを立てる</h3>
      <form id="new-thread-form">
        <input type="hidden" id="new-thread-genre">
        <input type="text" id="new-thread-title" placeholder="スレッドタイトル" required>
        <input type="text" id="new-thread-author" placeholder="名前 (省略可)">
        <textarea id="new-thread-body" placeholder="最初の書き込み" rows="4" required></textarea>
        <button type="submit">スレッド作成</button>
      </form>
    </div>
    
    <!-- スレッド内容ビュー -->
    <div id="thread-content-view" class="view">
      <div class="bookmark-controls">
        <button id="open-bookmarks-top" onclick="openBookmarkModal()">栞を開く</button>
      </div>
      <button class="back-button" id="back-to-thread-list-btn">&laquo; スレッド一覧に戻る</button>
      <h2 id="thread-title"></h2>
      <div id="posts-container"></div>
      <div id="pagination-container"></div>
      <hr>
      <h3>レスを書き込む</h3>
      <form id="new-post-form">
        <input type="hidden" id="current-thread-id">
        <input type="text" id="new-post-author" placeholder="名前 (省略可)">
        <textarea id="new-post-body" placeholder="書き込み内容" rows="4" required></textarea>
        <button type="submit">書き込む</button>
      </form>
      <div class="bookmark-controls">
        <button id="open-bookmarks-bottom" onclick="openBookmarkModal()">栞を開く</button>
      </div>
    </div>
  </main>

  <!-- 栞モーダル -->
  <div id="bookmark-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <button class="modal-close" onclick="closeBookmarkModal()">×</button>
      <div id="bookmark-view-content">
        <!-- 栞の中身はJSで生成 -->
      </div>
    </div>
  </div>

<script type="module">
  // Firebase認証スクリプト (変更なし)
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  const firebaseConfig = {"apiKey":"AIzaSyDSfTZRS0Smjnxns4hEzDibrY9dDIEMpgQ","authDomain":"thread-fb369.firebaseapp.com","projectId":"thread-fb369","storageBucket":"thread-fb369.firebasestorage.app","messagingSenderId":"259512543030","appId":"1:259512543030:web:cb6674ae37384371c0b597","measurementId":"G-2EWG4EWCQR"};
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const provider = new GoogleAuthProvider();
  window.authState = { user: null, idToken: null };
  onAuthStateChanged(auth, async (user) => {
    const userDisplay = document.getElementById('user-display');
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const newThreadAuthorInput = document.getElementById('new-thread-author');
    const newPostAuthorInput = document.getElementById('new-post-author');
    if (user) {
      window.authState.user = user;
      window.authState.idToken = await user.getIdToken(true);
      userDisplay.textContent = `${user.displayName} さん`;
      loginBtn.style.display = 'none';
      logoutBtn.style.display = 'inline';
      if(newThreadAuthorInput) { newThreadAuthorInput.value = user.displayName; newThreadAuthorInput.readOnly = true; }
      if(newPostAuthorInput) { newPostAuthorInput.value = user.displayName; newPostAuthorInput.readOnly = true; }
    } else {
      window.authState.user = null;
      window.authState.idToken = null;
      userDisplay.textContent = '';
      loginBtn.style.display = 'inline';
      logoutBtn.style.display = 'none';
      if(newThreadAuthorInput) { newThreadAuthorInput.value = ''; newThreadAuthorInput.readOnly = false; newThreadAuthorInput.placeholder = "名前 (省略可)"; }
      if(newPostAuthorInput) { newPostAuthorInput.value = ''; newPostAuthorInput.readOnly = false; newPostAuthorInput.placeholder = "名前 (省略可)"; }
    }
  });
  window.login = async () => { try { await signInWithPopup(auth, provider); } catch (error) { console.error("ログインエラー:", error); } };
  window.logout = async () => { await signOut(auth); };
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const CHUNK_SIZE = 50;
    let currentState = {};
    let isLoadingPosts = false;

    // --- DOM Elements ---
    const views = {
        home: document.getElementById('home-view'),
        threadList: document.getElementById('thread-list-view'),
        threadContent: document.getElementById('thread-content-view'),
    };
    const genreListContainer = document.getElementById('genre-list');
    const threadListContainer = document.getElementById('thread-list');
    const postsContainer = document.getElementById('posts-container');
    const bookmarkModal = document.getElementById('bookmark-modal');
    const bookmarkViewContent = document.getElementById('bookmark-view-content');
    
    // --- Bookmark Manager ---
    const BookmarkManager = {
        key: 'bbs_bookmarks',
        getAll: () => JSON.parse(localStorage.getItem(BookmarkManager.key) || '{}'),
        saveAll: (data) => localStorage.setItem(BookmarkManager.key, JSON.stringify(data)),
        toggle: (threadId, threadTitle, post) => {
            const allData = BookmarkManager.getAll();
            if (!allData[threadId]) { allData[threadId] = { title: threadTitle, bookmarks: {} }; }
            const threadBookmarks = allData[threadId].bookmarks;
            if (threadBookmarks[post.post_number]) { delete threadBookmarks[post.post_number]; } 
            else { threadBookmarks[post.post_number] = { content: post.body, timestamp: Date.now() }; }
            if (Object.keys(threadBookmarks).length === 0) { delete allData[threadId]; }
            BookmarkManager.saveAll(allData);
            return !!threadBookmarks[post.post_number];
        },
        isBookmarked: (threadId, postNumber) => {
            const threadData = BookmarkManager.getAll()[threadId];
            return !!(threadData && threadData.bookmarks[postNumber]);
        },
        removeForThread: (threadId) => {
            const allData = BookmarkManager.getAll();
            delete allData[threadId];
            BookmarkManager.saveAll(allData);
        },
        removeSingle: (threadId, postNumber) => {
             const allData = BookmarkManager.getAll();
             if(allData[threadId] && allData[threadId].bookmarks[postNumber]) {
                 delete allData[threadId].bookmarks[postNumber];
                 if (Object.keys(allData[threadId].bookmarks).length === 0) { delete allData[threadId]; }
                 BookmarkManager.saveAll(allData);
             }
        }
    };

    // --- Theme Switcher ---
    const themeSwitcher = document.querySelector('.theme-switcher');
    const themeButtons = themeSwitcher.querySelectorAll('button');
    const applyTheme = (theme) => {
        document.body.setAttribute('data-theme', theme);
        themeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.theme === theme));
        localStorage.setItem('theme', theme);
    };
    themeSwitcher.addEventListener('click', (e) => (e.target.tagName === 'BUTTON') && applyTheme(e.target.dataset.theme));
    applyTheme(localStorage.getItem('theme') || 'classic');

    // --- Helper Functions ---
    const escapeHTML = (str) => str.replace(/[&<>"']/g, (match) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
    async function handleApiError(response) { try { const d = await response.json(); throw new Error(d.error || '不明なエラー'); } catch (e) { throw new Error('サーバー通信失敗'); } }
    const parseUTCDate = (dateString) => dateString ? new Date(dateString.replace(' ', 'T') + 'Z') : null;
    const getRelativeTime = (timestamp) => {
        const diff = (new Date() - new Date(timestamp)) / 1000;
        const MIN = 60, HOUR = 3600, DAY = 86400, WEEK = 604800, MONTH = 2629746, YEAR = 31556952;
        if (diff < HOUR) return `${Math.floor(diff / MIN)}分前`;
        if (diff < DAY) return `${Math.floor(diff / HOUR)}時間前`;
        if (diff < WEEK) return `${Math.floor(diff / DAY)}日前`;
        if (diff < MONTH) return `${Math.floor(diff / WEEK)}週間前`;
        if (diff < YEAR) return `${Math.floor(diff / MONTH)}ヶ月前`;
        return `${Math.floor(diff / YEAR)}年前`;
    };

    // --- Navigation & Router ---
    window.navigate = (path) => { history.pushState(null, '', path); router(); };
    const parsePath = () => {
        const parts = window.location.pathname.split('/').filter(p => p);
        if (parts.length === 2) return { view: 'threadContent', genre: parts[0], threadId: parts[1] };
        if (parts.length === 1) return { view: 'threadList', genre: parts[0] };
        return { view: 'home' };
    };
    const router = async () => {
        const route = parsePath();
        const jumpToPostNumber = history.state?.jumpToPostNumber;
        history.replaceState(null, '', window.location.pathname); 

        currentState = { ...route, jumpToPostNumber };
        let nextView;
        try {
            switch (route.view) {
                case 'threadContent': await prepareThreadContentView(route.threadId, jumpToPostNumber); nextView = views.threadContent; break;
                case 'threadList': await prepareThreadListView(route.genre); nextView = views.threadList; break;
                default: await prepareHomeView(); nextView = views.home; break;
            }
            Object.values(views).forEach(v => v.style.display = 'none');
            if (nextView) nextView.style.display = 'block';
        } catch (error) { console.error(error); alert(error.message); }
    };

    // --- View Preparation Functions ---
    const prepareHomeView = async () => { /* 変更なし */ };
    const prepareThreadListView = async (genre) => { /* 変更なし */ };

    const prepareThreadContentView = async (threadId, jumpToPostNumber = null) => {
        postsContainer.innerHTML = '読み込み中...';
        const infoRes = await fetch(`/api/threads/${threadId}/info`, { cache: 'no-cache' });
        if (!infoRes.ok) await handleApiError(infoRes);
        const threadInfo = await infoRes.json();
        currentState.threadInfo = threadInfo;
        
        document.getElementById('thread-title').textContent = threadInfo.title;
        document.getElementById('current-thread-id').value = threadInfo.id;
        
        let posts = [];
        if (jumpToPostNumber) {
            const targetChunk = Math.floor((jumpToPostNumber - 1) / CHUNK_SIZE);
            const latestChunk = Math.floor((threadInfo.post_count - 1) / CHUNK_SIZE);
            const chunksToFetch = Array.from({length: latestChunk - targetChunk + 1}, (_, i) => targetChunk + i);
            const promises = chunksToFetch.map(i => fetch(`/api/threads/${threadId}/posts?chunk=${i}`, { cache: 'no-cache' }).then(res => res.json()));
            posts = (await Promise.all(promises)).flat();
            renderPosts(posts, true);
            setTimeout(() => document.getElementById(`post-${jumpToPostNumber}`)?.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100);
        } else {
            const latestChunk = Math.floor((threadInfo.post_count - 1) / CHUNK_SIZE);
            const chunksToFetch = latestChunk > 0 ? [latestChunk - 1, latestChunk] : [latestChunk];
            const promises = chunksToFetch.map(i => fetch(`/api/threads/${threadId}/posts?chunk=${i}`, { cache: 'no-cache' }).then(res => res.json()));
            posts = (await Promise.all(promises)).flat();
            const latest50Posts = posts.sort((a,b) => a.post_number - b.post_number).slice(-50);
            renderPosts(latest50Posts, true);
        }
        
        currentState.loadedChunks = new Set(posts.map(p => Math.floor((p.post_number-1)/CHUNK_SIZE)));
    };
    
    // --- Post Rendering ---
    const renderPosts = (posts, clear = true, prepend = false) => {
        if(clear) postsContainer.innerHTML = '';
        const sortedPosts = posts.sort((a, b) => a.post_number - b.post_number);
        const fragment = document.createDocumentFragment();
        sortedPosts.forEach(post => {
            const div = document.createElement('div');
            div.className = 'post';
            div.id = `post-${post.post_number}`;
            const isBookmarked = BookmarkManager.isBookmarked(currentState.threadId, post.post_number);
            const formattedDate = parseUTCDate(post.created_at)?.toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
            div.innerHTML = `<div class="post-header"><span><span class="post-number">${post.post_number}</span>: ${escapeHTML(post.author || '名無しさん')}<i class="bookmark-icon">${isBookmarked ? '🔖' : '📎'}</i></span><span class="post-date">${formattedDate}</span></div><div class="post-body">${escapeHTML(post.body).replace(/\n/g, '<br>')}</div>`;
            div.querySelector('.post-number, .bookmark-icon').addEventListener('click', () => {
                const isNowBookmarked = BookmarkManager.toggle(currentState.threadId, currentState.threadInfo.title, post);
                div.querySelector('.bookmark-icon').textContent = isNowBookmarked ? '🔖' : '📎';
            });
            fragment.appendChild(div);
        });
        if (prepend) postsContainer.prepend(fragment);
        else postsContainer.appendChild(fragment);
    };
    
    // --- Bookmark Modal Logic ---
    window.openBookmarkModal = (threadId = null) => {
        prepareBookmarkView(threadId);
        bookmarkModal.style.display = 'flex';
    };
    window.closeBookmarkModal = () => { bookmarkModal.style.display = 'none'; };

    const prepareBookmarkView = (threadId) => {
        bookmarkViewContent.innerHTML = '';
        const allBookmarks = BookmarkManager.getAll();

        if (threadId) { // スレッド別栞ページ
            const threadData = allBookmarks[threadId];
            const title = document.createElement('h2');
            title.textContent = `栞: ${escapeHTML(threadData?.title || '不明なスレッド')}`;
            const backBtn = document.createElement('button');
            backBtn.className = 'back-button';
            backBtn.textContent = '« 栞一覧に戻る';
            backBtn.onclick = () => prepareBookmarkView(null);
            bookmarkViewContent.append(backBtn, title);
            
            if (threadData && Object.keys(threadData.bookmarks).length > 0) {
                 Object.entries(threadData.bookmarks).sort((a,b) => a[0] - b[0]).forEach(([postNumber, bookmark]) => {
                    const item = document.createElement('div');
                    item.className = 'bookmark-item list-item';
                    item.innerHTML = `<div style="flex-grow: 1;"><strong>レス ${postNumber}</strong><div class="post-body">${escapeHTML(bookmark.content)}</div></div><button class="bookmark-delete-btn">削除</button>`;
                    item.querySelector('.bookmark-delete-btn').onclick = (e) => { e.stopPropagation(); BookmarkManager.removeSingle(threadId, postNumber); prepareBookmarkView(threadId); };
                    item.onclick = () => jumpToBookmark(threadId, postNumber);
                    bookmarkViewContent.appendChild(item);
                });
            } else { bookmarkViewContent.insertAdjacentHTML('beforeend', '<p>このスレッドの栞はありません。</p>'); }

        } else { // 栞トップページ
            const title = document.createElement('h2');
            title.textContent = '栞一覧';
            bookmarkViewContent.appendChild(title);
            
            if (Object.keys(allBookmarks).length > 0) {
                Object.entries(allBookmarks).forEach(([tid, threadData]) => {
                    const newestBookmark = Object.entries(threadData.bookmarks).sort((a,b) => b[0] - a[0])[0];
                    if (!newestBookmark) return;
                    const [postNumber, bookmark] = newestBookmark;
                    const item = document.createElement('div');
                    item.className = 'bookmark-item list-item';
                    item.innerHTML = `<div style="flex-grow: 1;"><div><strong>${escapeHTML(threadData.title)}</strong></div><small>レス ${postNumber} (${getRelativeTime(bookmark.timestamp)})</small></div><div style="text-align: right;"><button class="view-thread-bookmarks-btn">全件表示</button><button class="bookmark-delete-btn">全削除</button></div>`;
                    item.querySelector('.view-thread-bookmarks-btn').onclick = (e) => { e.stopPropagation(); prepareBookmarkView(tid); };
                    item.querySelector('.bookmark-delete-btn').onclick = (e) => { e.stopPropagation(); if (confirm(`「${threadData.title}」の栞をすべて削除しますか？`)) { BookmarkManager.removeForThread(tid); prepareBookmarkView(); } };
                    item.onclick = () => jumpToBookmark(tid, postNumber);
                    bookmarkViewContent.appendChild(item);
                });
            } else { bookmarkViewContent.insertAdjacentHTML('beforeend', '<p>栞はまだありません。</p>'); }
        }
    };
    
    const jumpToBookmark = (threadId, postNumber) => {
        closeBookmarkModal();
        const currentRoute = parsePath();
        const genre = currentRoute.view === 'threadContent' && currentRoute.threadId === threadId ? currentRoute.genre : 'unknown-genre';
        history.pushState({ jumpToPostNumber: parseInt(postNumber, 10) }, '', `/${genre}/${threadId}`);
        router();
    };

    // --- Infinite Scroll ---
    window.addEventListener('scroll', async () => {
        if (isLoadingPosts || views.threadContent.style.display !== 'block' || window.scrollY > 50) return;
        isLoadingPosts = true;
        try {
            const firstPostEl = postsContainer.querySelector('.post');
            if (!firstPostEl) return;
            const firstPostNum = parseInt(firstPostEl.id.replace('post-', ''), 10);
            if (firstPostNum <= 1) return;

            const chunkToLoad = Math.floor((firstPostNum - 2) / CHUNK_SIZE);
            if (chunkToLoad < 0 || currentState.loadedChunks.has(chunkToLoad)) return;

            const res = await fetch(`/api/threads/${currentState.threadId}/posts?chunk=${chunkToLoad}`, { cache: 'no-cache' });
            if (!res.ok) return;
            const olderPosts = await res.json();
            if(olderPosts.length === 0) { currentState.loadedChunks.add(chunkToLoad); return; }
            
            const currentScrollHeight = document.documentElement.scrollHeight;
            renderPosts(olderPosts, false, true);
            window.scrollTo(0, document.documentElement.scrollHeight - currentScrollHeight);
            currentState.loadedChunks.add(chunkToLoad);
        } finally { isLoadingPosts = false; }
    });

    // --- Event Handlers & Form Submissions ---
    document.querySelector('header a').onclick = (e) => { e.preventDefault(); navigate('/'); };
    document.getElementById('back-to-home-btn').onclick = () => navigate('/');
    document.getElementById('back-to-thread-list-btn').onclick = () => navigate(`/${currentState.genre}`);
    window.addEventListener('popstate', router);
    document.getElementById('new-thread-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const idToken = window.authState.idToken;
        const headers = { 'Content-Type': 'application/json' };
        if (idToken) headers['Authorization'] = `Bearer ${idToken}`;
        const form = e.target, btn = form.querySelector('button'), genre = form.elements['new-thread-genre'].value;
        btn.disabled = true;
        try {
            const res = await fetch('/api/threads', { method: 'POST', headers, body: JSON.stringify({ genre, title: form.elements['new-thread-title'].value, author: form.elements['new-thread-author'].value, body: form.elements['new-thread-body'].value }) });
            if (!res.ok) await handleApiError(res);
            form.reset();
            if (window.authState.user) form.elements['new-thread-author'].value = window.authState.user.displayName;
            await prepareThreadListView(genre); 
        } catch(err) { console.error(err); alert(err.message); } finally { btn.disabled = false; }
    });
    document.getElementById('new-post-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const idToken = window.authState.idToken;
        const headers = { 'Content-Type': 'application/json' };
        if (idToken) headers['Authorization'] = `Bearer ${idToken}`;
        const form = e.target, btn = form.querySelector('button'), threadId = form.elements['current-thread-id'].value;
        btn.disabled = true;
        try {
            const res = await fetch(`/api/threads/${threadId}/posts`, { method: 'POST', headers, body: JSON.stringify({ author: form.elements['new-post-author'].value, body: form.elements['new-post-body'].value }) });
            if (!res.ok) await handleApiError(res);
            const { new_post_count, latest_chunk_posts } = await res.json();
            form.reset();
            if (window.authState.user) form.elements['new-post-author'].value = window.authState.user.displayName;
            renderPosts(latest_chunk_posts, true);
            currentState.threadInfo.post_count = new_post_count;
        } catch(err) { console.error(err); alert(err.message); } finally { btn.disabled = false; }
    });

    // --- Initial Load ---
    router();
});
</script>
</body>
</html>