<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cloudflare BBS</title>
  <style>
    /* (CSSは変更なし) */
    :root {
      --font-classic: 'MS PGothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
      --font-modern: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans CJK JP', 'Noto Sans JP', sans-serif;
    }
    body[data-theme="classic"] {
      --font-family: var(--font-classic); --bg-color: #efefef; --main-bg-color: #fff; --text-color: #333; --header-bg-color: #ddd; --border-color: #ccc; --accent-color: #99c; --link-color: #007bff; --link-hover-color: #0056b3; --post-name-color: #006400; --post-meta-color: #555; --post-border-color: #eee; --thread-hover-bg: #f0f8ff; --card-radius: 0px; --card-shadow: none;
    }
    body[data-theme="modern"] {
      --font-family: var(--font-modern); --bg-color: #f4f7f9; --main-bg-color: #ffffff; --text-color: #2c3e50; --header-bg-color: #ffffff; --border-color: #e0e6ed; --accent-color: #3498db; --link-color: #3498db; --link-hover-color: #2980b9; --post-name-color: #27ae60; --post-meta-color: #7f8c8d; --post-border-color: transparent; --thread-hover-bg: #ecf5ff; --card-radius: 8px; --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }
    body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); margin: 0; transition: background-color 0.2s, color 0.2s; }
    header { background-color: var(--header-bg-color); padding: 10px; border-bottom: 1px solid var(--border-color); box-shadow: var(--card-shadow); position: sticky; top: 0; z-index: 10; }
    .header-content { max-width: 800px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
    .header-left, .header-right { display: flex; align-items: center; gap: 10px; flex: 1; }
    .header-right { justify-content: flex-end; }
    .header-content h1 { margin: 0; font-size: 1.5em; flex: 2; text-align: center; }
    .header-nav-btn, #auth-controls-header button { padding: 5px 10px; font-size: 0.9em; }
    #auth-controls-header { display: flex; align-items: center; gap: 5px; }
    main { max-width: 800px; margin: 20px auto; background-color: var(--main-bg-color); padding: 20px; border: 1px solid var(--border-color); border-radius: var(--card-radius); }
    h2, h3 { border-bottom: 2px solid var(--accent-color); padding-bottom: 5px; }
    form { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
    input, textarea, select { padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; font-family: inherit; font-size: 1em; background-color: var(--bg-color); color: var(--text-color); }
    input:focus, textarea:focus, select:focus { outline: none; border-color: var(--link-color); box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2); }
    button { padding: 10px; background-color: var(--link-color); color: white; border: none; cursor: pointer; border-radius: 4px; font-size: 1em; font-weight: bold; transition: background-color 0.2s; }
    button:hover { background-color: var(--link-hover-color); }
    button:disabled { background-color: #6c757d; cursor: not-allowed; }
    fieldset { border: 1px solid var(--border-color); border-radius: 4px; padding: 15px; margin-bottom: 10px; }
    legend { font-weight: bold; color: var(--text-color); padding: 0 5px; }
    .fieldset-row { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
    .fieldset-row label { display: flex; align-items: center; gap: 5px; }
    .theme-switcher { margin-bottom: 10px; text-align: right; }
    .theme-switcher button { padding: 5px 10px; font-size: 0.8em; margin-left: 5px; background-color: #ccc; color: #333; font-weight: normal; }
    .theme-switcher button.active { background-color: var(--link-color); color: white; }
    .list-item, #thread-list .thread-item { cursor: pointer; padding: 10px; border-bottom: 1px dotted var(--border-color); display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; text-decoration: none; color: inherit; }
    .list-item:hover, #thread-list .thread-item:hover { background-color: var(--thread-hover-bg); }
    .thread-details { flex-grow: 1; }
    .thread-meta { font-size: 0.8em; color: #666; text-align: right; white-space: nowrap; }
    .post { margin-bottom: 15px; padding-left: 10px; border-left: 3px solid var(--post-border-color); transition: background-color 0.2s, border-color 0.2s; }
    .post-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; color: var(--post-name-color); font-weight: bold; cursor: pointer; }
    .post-header-main { display: flex; align-items: center; }
    .post-header .post-date { color: var(--post-meta-color); font-weight: normal; margin-left: 10px; }
    .post-body { margin-left: 1em; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; }
    .post-number { text-decoration: underline; }
    .bookmark-icon { margin-left: 5px; color: var(--accent-color); font-style: normal; }
    .post.bookmarked { background-color: var(--thread-hover-bg); border-left-color: var(--accent-color); }
    body[data-theme="modern"] .post { border-left: none; padding: 15px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 6px; }
    body[data-theme="modern"] .post-body { margin-left: 0; }
    body[data-theme="modern"] .post.bookmarked { border: 1px solid var(--accent-color); background-color: var(--thread-hover-bg); box-shadow: 0 1px 4px rgba(52, 152, 219, 0.2); }
    #posts-loader { text-align: center; margin-bottom: 15px; }
    .view { display: none; }
    
    /* --- 栞モーダルのスタイル（本のように） --- */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content {
        background-color: #fdf6e3; color: #586e75; font-family: 'Georgia', 'Yu Mincho', 'Hiragino Mincho ProN', serif;
        width: 90%; max-width: 800px; height: 80vh; max-height: 600px;
        padding: 40px 50px 60px 50px; border: 1px solid #d3c2a5; border-radius: 2px 10px 10px 2px;
        box-shadow: -10px 10px 15px rgba(0, 0, 0, 0.3), inset 0 0 20px rgba(0, 0, 0, 0.1);
        position: relative; overflow-y: auto;
    }
    .modal-content::before { content: ''; position: absolute; top: 0; left: 50%; width: 30px; height: 100%; transform: translateX(-50%); background: linear-gradient(to right, rgba(0,0,0,0) 0%, rgba(0,0,0,0.15) 45%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.15) 55%, rgba(0,0,0,0) 100%); pointer-events: none; border-radius: inherit; }
    .modal-content::after { content: ''; position: absolute; top: -2px; left: 58%; width: 15px; height: 60px; background-color: #b52a32; border: 1px solid rgba(0,0,0,0.2); border-top: none; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; box-shadow: 0 3px 5px rgba(0,0,0,0.2); z-index: 1; }
    .modal-close { position: absolute; top: 10px; right: 15px; font-size: 2em; line-height: 1; background: none; border: none; color: #839496; cursor: pointer; z-index: 2; transition: color 0.2s; }
    .modal-close:hover { color: #002b36; }
    #bookmark-view-content h3 { text-align: center; font-size: 1.5em; border-bottom: 2px solid #b58900; padding-bottom: 15px; margin-bottom: 25px; color: #657b83; }
    #bookmark-view-content .bookmark-item { border-bottom: 1px dashed #d3c2a5; padding: 15px 5px; cursor: pointer; transition: background-color 0.2s; display: flex; justify-content: space-between; align-items: center; }
    #bookmark-view-content .bookmark-item:hover { background-color: rgba(181, 137, 0, 0.08); }
    #bookmark-view-content .post-summary, #bookmark-view-content .post-body { color: #657b83; font-size: 0.95em; }
    #bookmark-view-content .post-summary { margin-top: 4px; }
    #bookmark-view-content .post-body { max-height: 3.2em; overflow: hidden; }
    #bookmark-view-content button { font-family: var(--font-modern); font-size: 0.8em; padding: 4px 8px; border: 1px solid #b58900; background-color: transparent; color: #b58900; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    #bookmark-view-content button:hover { background-color: #b58900; color: #fdf6e3; }
    #bookmark-view-content .back-button { margin-bottom: 15px !important; }
    #bookmark-view-content .bookmark-delete-btn { border-color: #dc3545; color: #dc3545; }
    #bookmark-view-content .bookmark-delete-btn:hover { background-color: #dc3545; color: #fff; }
    #bookmark-options { position: absolute; bottom: 15px; left: 50px; font-size: 0.9em; color: #657b83; z-index: 2; }
    #bookmark-options label { display: flex; align-items: center; gap: 5px; cursor: pointer; }
    #bookmark-options input { width: auto; padding: 0; margin: 0; }
  </style>
</head>
<body data-theme="classic">

  <header>
    <div class="header-content">
      <div class="header-left">
        <button id="back-to-home-btn-header" class="header-nav-btn" style="display: none;">&laquo; ジャンル一覧</button>
        <button id="back-to-thread-list-btn-header" class="header-nav-btn" style="display: none;">&laquo; スレッド一覧</button>
      </div>
      <h1><a href="/" style="text-decoration: none; color: inherit;">Cloudflare BBS</a></h1>
      <div class="header-right">
        <button id="open-bookmarks-header" class="header-nav-btn" onclick="openBookmarkModal()">栞</button>
        <div id="auth-controls-header">
            <span id="user-display"></span>
            <button id="change-name-btn" style="display:none;">名前変更</button>
            <button id="login-btn" onclick="login()">ログイン</button>
            <button id="logout-btn" onclick="logout()" style="display:none;">ログアウト</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="theme-switcher">
        <button data-theme="classic">クラシック</button>
        <button data-theme="modern">モダン</button>
    </div>
    <div id="home-view" class="view"><h2>ジャンル一覧</h2><div id="genre-list"></div></div>
    <div id="thread-list-view" class="view">
      <h2 id="thread-list-title"></h2>
      <div id="thread-list"></div><hr>
      <button id="show-new-thread-form-btn">新しいスレッドを立てる</button>
    </div>
    <div id="new-thread-view" class="view">
        <h2 id="new-thread-view-title">新しいスレッドを立てる</h2>
        <form id="new-thread-form">
            <input type="hidden" id="new-thread-genre">
            <input type="text" id="new-thread-title" placeholder="スレッドタイトル" required>
            <input type="text" id="new-thread-author" placeholder="あなたの名前 (省略可)">
            <textarea id="new-thread-body" placeholder="最初の書き込み" rows="4" required></textarea>
            
            <fieldset>
                <legend>書き込み設定</legend>
                <div>
                    <strong>誰が書き込めるか？</strong>
                    <div class="fieldset-row">
                        <label><input type="radio" name="write_permission" value="public" checked> 誰でも</label>
                        <label><input type="radio" name="write_permission" value="authenticated"> ログインユーザーのみ</label>
                    </div>
                </div>
                <hr style="border: none; border-top: 1px dotted var(--border-color); margin: 10px 0;">
                <div>
                    <strong>名前の扱い</strong>
                    <div class="fieldset-row">
                        <label><input type="radio" name="name_setting" value="user_choice" checked> 各ユーザーが自由に入力</label>
                    </div>
                    <div class="fieldset-row">
                        <label><input type="radio" name="name_setting" value="fixed"> 全員固定:</label>
                        <input type="text" id="fixed_name_input" placeholder="例: 名無しさん" style="flex-grow: 1; padding: 5px;" disabled>
                    </div>
                    <div class="fieldset-row">
                        <label><input type="radio" name="name_setting" value="account_linked" disabled> ログイン名を強制使用</label>
                    </div>
                </div>
            </fieldset>

            <button type="submit">スレッド作成</button>
        </form>
    </div>
    <div id="thread-content-view" class="view">
      <h2 id="thread-title"></h2>
      <div id="posts-loader"></div><div id="posts-container"></div><hr>
      <div id="new-post-form-container">
        <h3>レスを書き込む</h3>
        <form id="new-post-form"><input type="hidden" id="current-thread-id"><input type="text" id="new-post-author" placeholder="名前 (省略可)"><textarea id="new-post-body" placeholder="書き込み内容" rows="4" required></textarea><button type="submit">書き込む</button></form>
      </div>
    </div>
  </main>

  <!-- 栞モーダル -->
  <div id="bookmark-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <button class="modal-close" onclick="closeBookmarkModal()">×</button>
      <div id="bookmark-view-content"></div>
      <div id="bookmark-options">
        <label>
          <input type="checkbox" id="auto-delete-bookmark-checkbox">
          ジャンプ後に栞を自動削除する
        </label>
      </div>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  const firebaseConfig = {"apiKey":"AIzaSyDSfTZRS0Smjnxns4hEzDibrY9dDIEMpgQ","authDomain":"thread-fb369.firebaseapp.com","projectId":"thread-fb369","storageBucket":"thread-fb369.firebasestorage.app","messagingSenderId":"259512543030","appId":"1:259512543030:web:cb6674ae37384371c0b597","measurementId":"G-2EWG4EWCQR"};
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const provider = new GoogleAuthProvider();
  window.authState = { user: null, idToken: null };

  const CUSTOM_NAME_KEY = 'bbs_custom_username';

  // ★★★ 修正箇所 ★★★
  function updateUserFields(user, customName) {
      const name = customName || (user ? user.displayName : '');
      const userDisplay = document.getElementById('user-display');
      const newThreadAuthorInput = document.getElementById('new-thread-author');
      
      if (user) {
          userDisplay.textContent = `${name} さん`;
          // スレッド作成時、ログインユーザーは名前を編集できるようにする
          if (newThreadAuthorInput) {
              newThreadAuthorInput.value = name;
              newThreadAuthorInput.readOnly = false; // ★ 編集可能にする
          }
      } else {
          userDisplay.textContent = '';
          if (newThreadAuthorInput) {
              newThreadAuthorInput.value = '';
              newThreadAuthorInput.readOnly = false;
              newThreadAuthorInput.placeholder = "名前 (省略可)";
          }
      }
  }

  onAuthStateChanged(auth, async (user) => {
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const changeNameBtn = document.getElementById('change-name-btn');

    if (user) {
      window.authState.user = user;
      window.authState.idToken = await user.getIdToken(true);
      const customName = localStorage.getItem(CUSTOM_NAME_KEY);
      updateUserFields(user, customName);
      loginBtn.style.display = 'none';
      logoutBtn.style.display = 'inline-block';
      changeNameBtn.style.display = 'inline-block';
    } else {
      window.authState.user = null;
      window.authState.idToken = null;
      updateUserFields(null, null);
      loginBtn.style.display = 'inline-block';
      logoutBtn.style.display = 'none';
      changeNameBtn.style.display = 'none';
    }
    
    if (document.getElementById('thread-content-view').style.display === 'block' && window.currentState && window.currentState.threadInfo) {
        window.updatePostFormControls(window.currentState.threadInfo);
    }
  });

  document.getElementById('change-name-btn').addEventListener('click', () => {
    const user = window.authState.user;
    if (!user) return;
    const currentCustomName = localStorage.getItem(CUSTOM_NAME_KEY) || '';
    const newName = prompt('新しい名前を入力してください（空にするとGoogleアカウント名に戻ります）:', currentCustomName);

    if (newName !== null) {
        if (newName.trim() === '') {
            localStorage.removeItem(CUSTOM_NAME_KEY);
            updateUserFields(user, null);
        } else {
            localStorage.setItem(CUSTOM_NAME_KEY, newName);
            updateUserFields(user, newName);
        }
        if (document.getElementById('thread-content-view').style.display === 'block' && window.currentState && window.currentState.threadInfo) {
            window.updatePostFormControls(window.currentState.threadInfo);
        }
    }
  });

  window.login = async () => { try { await signInWithPopup(auth, provider); } catch (error) { console.error("ログインエラー:", error); } };
  window.logout = async () => { await signOut(auth); };
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- 設定値 ---
    const CHUNK_SIZE = 50;
    const POSTS_PER_PAGE = 200;

    let currentState = {};
    let isLoadingPosts = false;

    // --- DOM Elements ---
    const views = { home: document.getElementById('home-view'), threadList: document.getElementById('thread-list-view'), newThread: document.getElementById('new-thread-view'), threadContent: document.getElementById('thread-content-view') };
    const genreListContainer = document.getElementById('genre-list');
    const threadListContainer = document.getElementById('thread-list');
    const postsContainer = document.getElementById('posts-container');
    const postsLoader = document.getElementById('posts-loader');
    const bookmarkModal = document.getElementById('bookmark-modal');
    const bookmarkViewContent = document.getElementById('bookmark-view-content');
    const backToHomeBtnHeader = document.getElementById('back-to-home-btn-header');
    const backToThreadListBtnHeader = document.getElementById('back-to-thread-list-btn-header');
    const autoDeleteBookmarkCheckbox = document.getElementById('auto-delete-bookmark-checkbox');
    
    // --- Bookmark Manager (変更なし) ---
    const BookmarkManager = {
        key: 'bbs_bookmarks',
        getAll: () => JSON.parse(localStorage.getItem(BookmarkManager.key) || '{}'),
        saveAll: (data) => localStorage.setItem(BookmarkManager.key, JSON.stringify(data)),
        toggle: (threadId, threadTitle, post) => {
            const allData = BookmarkManager.getAll();
            if (!allData[threadId]) { allData[threadId] = { title: threadTitle, bookmarks: {} }; }
            const threadBookmarks = allData[threadId].bookmarks;
            if (threadBookmarks[post.post_number]) { delete threadBookmarks[post.post_number]; } 
            else { threadBookmarks[post.post_number] = { content: post.body }; }
            if (Object.keys(threadBookmarks).length === 0) { delete allData[threadId]; }
            BookmarkManager.saveAll(allData);
            return !!threadBookmarks[post.post_number];
        },
        isBookmarked: (threadId, postNumber) => {
            const threadData = BookmarkManager.getAll()[threadId];
            return !!(threadData && threadData.bookmarks[postNumber]);
        },
        removeForThread: (threadId) => {
            const allData = BookmarkManager.getAll();
            delete allData[threadId];
            BookmarkManager.saveAll(allData);
        },
        removeSingle: (threadId, postNumber) => {
             const allData = BookmarkManager.getAll();
             if(allData[threadId] && allData[threadId].bookmarks[postNumber]) {
                 delete allData[threadId].bookmarks[postNumber];
                 if (Object.keys(allData[threadId].bookmarks).length === 0) { delete allData[threadId]; }
                 BookmarkManager.saveAll(allData);
             }
        }
    };

    // --- Bookmark Auto-Delete Option (変更なし) ---
    const AUTO_DELETE_KEY = 'bbs_auto_delete_bookmark';
    const initAutoDeleteOption = () => {
        const savedValue = localStorage.getItem(AUTO_DELETE_KEY) === 'true';
        autoDeleteBookmarkCheckbox.checked = savedValue;
        autoDeleteBookmarkCheckbox.addEventListener('change', (e) => {
            localStorage.setItem(AUTO_DELETE_KEY, e.target.checked);
        });
    };
    initAutoDeleteOption();

    // --- Theme Switcher (変更なし) ---
    const themeSwitcher = document.querySelector('.theme-switcher');
    const themeButtons = themeSwitcher.querySelectorAll('button');
    const applyTheme = (theme) => {
        document.body.setAttribute('data-theme', theme);
        themeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.theme === theme));
        localStorage.setItem('theme', theme);
    };
    themeSwitcher.addEventListener('click', (e) => (e.target.tagName === 'BUTTON') && applyTheme(e.target.dataset.theme));
    applyTheme(localStorage.getItem('theme') || 'classic');

    // --- Helper Functions (変更なし) ---
    const escapeHTML = (str) => str.replace(/[&<>"']/g, (match) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
    async function handleApiError(response) { try { const d = await response.json(); throw new Error(d.error || '不明なエラー'); } catch (e) { throw new Error('サーバー通信失敗'); } }
    const parseUTCDate = (dateString) => dateString ? new Date(dateString.replace(' ', 'T') + 'Z') : null;

    // --- Navigation & Router ---
    window.navigate = (path) => { history.pushState(null, '', path); router(); };
    const parsePath = () => {
        const parts = window.location.pathname.split('/').filter(p => p);
        if (parts[0] === 'new' && parts.length === 2) return { view: 'newThread', genre: parts[1] };
        if (parts.length === 2) return { view: 'threadContent', genre: parts[0], threadId: parts[1] };
        if (parts.length === 1) return { view: 'threadList', genre: parts[0] };
        return { view: 'home' };
    };
    const updateHeaderButtons = (view) => {
        backToHomeBtnHeader.style.display = (view === 'threadList') ? 'inline-block' : 'none';
        const showBackToThreadList = view === 'threadContent' || view === 'newThread';
        backToThreadListBtnHeader.style.display = showBackToThreadList ? 'inline-block' : 'none';
    };
    const router = async () => {
        const route = parsePath();
        const jumpToPostNumber = history.state?.jumpToPostNumber;
        history.replaceState(null, '', window.location.pathname); 

        window.currentState = { ...route, jumpToPostNumber };
        let nextView;
        try {
            switch (route.view) {
                case 'threadContent': await prepareThreadContentView(route.threadId, jumpToPostNumber); nextView = views.threadContent; break;
                case 'newThread': prepareNewThreadView(route.genre); nextView = views.newThread; break;
                case 'threadList': await prepareThreadListView(route.genre); nextView = views.threadList; break;
                default: await prepareHomeView(); nextView = views.home; break;
            }
            Object.values(views).forEach(v => v.style.display = 'none');
            if (nextView) nextView.style.display = 'block';
            updateHeaderButtons(route.view);
        } catch (error) { console.error(error); alert(error.message); }
    };

    // --- View Preparation Functions ---
    const prepareHomeView = async () => {
        const res = await fetch('/api/genres', { cache: 'no-cache' });
        if (!res.ok) await handleApiError(res);
        const genres = await res.json();
        genreListContainer.innerHTML = '';
        if (genres && genres.length > 0) { genres.forEach(({ genre }) => { const a = document.createElement('a'); a.href = `/${genre}`; a.className = 'list-item'; a.innerHTML = `<strong>${escapeHTML(genre)}</strong>`; a.onclick = (e) => { e.preventDefault(); navigate(`/${genre}`); }; genreListContainer.appendChild(a); }); } else { genreListContainer.innerHTML = '<p>ジャンルはまだありません。</p>'; }
    };
    const prepareThreadListView = async (genre) => {
        const res = await fetch(`/api/threads?genre=${genre}`, { cache: 'no-cache' });
        if (!res.ok) await handleApiError(res);
        const threads = await res.json();
        document.getElementById('thread-list-title').textContent = `${escapeHTML(genre)} のスレッド一覧`;
        document.getElementById('show-new-thread-form-btn').onclick = () => navigate(`/new/${genre}`);
        threadListContainer.innerHTML = '';
        if (threads && threads.length > 0) { threads.forEach(thread => { const a = document.createElement('a'); a.href = `/${genre}/${thread.id}`; a.className = 'thread-item'; const lastUpdatedDate = parseUTCDate(thread.last_updated); const formattedDate = lastUpdatedDate.toLocaleString('ja-JP', { year: '2-digit', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }); a.innerHTML = `<div class="thread-details"><strong>${escapeHTML(thread.title)}</strong></div><div class="thread-meta">レス: ${thread.post_count}<br>更新: ${formattedDate}</div>`; a.onclick = (e) => { e.preventDefault(); navigate(`/${genre}/${thread.id}`); }; threadListContainer.appendChild(a); }); } else { threadListContainer.innerHTML = '<p>スレッドはまだありません。</p>'; }
    };
    
    const prepareNewThreadView = (genre) => {
        document.getElementById('new-thread-view-title').textContent = `新しいスレッドを立てる (${escapeHTML(genre)})`;
        const form = document.getElementById('new-thread-form');
        form.reset();
        document.getElementById('new-thread-genre').value = genre;
        // ログイン状態に応じて名前欄を再設定する処理は onAuthStateChanged 内の updateUserFields で行われる
    };

    window.updatePostFormControls = (threadInfo) => {
        const formContainer = document.getElementById('new-post-form-container');
        const form = document.getElementById('new-post-form');
        const authorInput = document.getElementById('new-post-author');
        const bodyInput = document.getElementById('new-post-body');
        const submitBtn = form.querySelector('button');

        formContainer.style.display = 'block';
        authorInput.disabled = false;
        bodyInput.disabled = false;
        submitBtn.disabled = false;
        submitBtn.textContent = '書き込む';
        authorInput.placeholder = "名前 (省略可)";
        
        if (threadInfo.write_permission === 'authenticated' && !window.authState.user) {
            formContainer.style.display = 'none';
            return;
        }

        switch (threadInfo.name_setting) {
            case 'fixed':
                authorInput.value = threadInfo.fixed_name || '名無しさん';
                authorInput.disabled = true;
                break;
            case 'account_linked':
                if (window.authState.user) {
                    authorInput.value = window.authState.user.displayName || '名無しさん';
                }
                authorInput.disabled = true;
                break;
            case 'user_choice':
            default:
                authorInput.disabled = false;
                if (window.authState.user) {
                    const customName = localStorage.getItem('bbs_custom_username');
                    authorInput.value = customName || window.authState.user.displayName;
                } else {
                    authorInput.value = '';
                }
                break;
        }
    };

    const prepareThreadContentView = async (threadId, jumpToPostNumber = null) => {
        postsContainer.innerHTML = '読み込み中...';
        postsLoader.innerHTML = '';
        const infoRes = await fetch(`/api/threads/${threadId}/info`, { cache: 'no-cache' });
        if (!infoRes.ok) await handleApiError(infoRes);
        const threadInfo = await infoRes.json();
        window.currentState = { ...window.currentState, threadInfo, threadId, posts: [], loadedChunks: new Set() };
        document.getElementById('thread-title').textContent = threadInfo.title;
        document.getElementById('current-thread-id').value = threadInfo.id;
        
        window.updatePostFormControls(threadInfo);

        let fetchedPosts = [];
        
        if (jumpToPostNumber) {
            const targetChunk = Math.floor((jumpToPostNumber - 1) / CHUNK_SIZE);
            const startChunk = Math.max(0, targetChunk - 1);
            const chunksNeededAfter = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const endChunk = targetChunk + chunksNeededAfter - 1;
            
            const chunksToFetch = Array.from({length: endChunk - startChunk + 1}, (_, i) => startChunk + i)
                .filter(cn => cn >= 0 && cn * CHUNK_SIZE < threadInfo.post_count);

            const initialPosts = await fetchPostChunks(chunksToFetch);
            
            const allFetchedPosts = initialPosts.sort((a,b) => a.post_number - b.post_number);
            const targetIndex = allFetchedPosts.findIndex(p => p.post_number === jumpToPostNumber);

            if (targetIndex !== -1) {
                const startIndex = Math.max(0, targetIndex - 50);
                const endIndex = targetIndex + POSTS_PER_PAGE;
                fetchedPosts = allFetchedPosts.slice(startIndex, endIndex);
            } else {
                fetchedPosts = allFetchedPosts;
            }

            const lastPostNumber = fetchedPosts[fetchedPosts.length - 1]?.post_number;
            if (lastPostNumber && lastPostNumber < threadInfo.post_count) {
                 const remainingPosts = threadInfo.post_count - lastPostNumber;
                 const nextChunk = Math.floor(lastPostNumber / CHUNK_SIZE);
                 postsLoader.insertAdjacentHTML('beforeend', `<button onclick="loadMorePosts(this, ${nextChunk})">続きから読む (${remainingPosts}レス)</button>`);
            }
        } else {
            const latestChunk = Math.floor((threadInfo.post_count - 1) / CHUNK_SIZE);
            const chunksNeeded = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const startChunk = Math.max(0, latestChunk - chunksNeeded + 1);
            const chunksToFetch = Array.from({length: latestChunk - startChunk + 1}, (_, i) => startChunk + i);
            fetchedPosts = (await fetchPostChunks(chunksToFetch)).sort((a,b) => a.post_number - b.post_number);
        }
        
        window.currentState.posts = fetchedPosts;
        renderPosts(true);
        
        if (jumpToPostNumber) { 
            setTimeout(() => document.getElementById(`post-${jumpToPostNumber}`)?.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100); 
        }
    };
    
    // --- Post Rendering & Loading (変更なし) ---
    const fetchPostChunks = async (chunkNumbers) => {
        const chunksToFetch = chunkNumbers.filter(cn => !window.currentState.loadedChunks.has(cn));
        if (chunksToFetch.length === 0) return [];
        const promises = chunksToFetch.map(i => { window.currentState.loadedChunks.add(i); return fetch(`/api/threads/${window.currentState.threadId}/posts?chunk=${i}`, { cache: 'no-cache' }).then(res => res.json()); });
        return (await Promise.all(promises)).flat();
    };
    
    const renderPosts = (clear = true) => {
        if(clear) postsContainer.innerHTML = '';
        const fragment = document.createDocumentFragment();
        window.currentState.posts.forEach(post => {
            if (document.getElementById(`post-${post.post_number}`)) return;
            const div = document.createElement('div');
            div.className = 'post';
            div.id = `post-${post.post_number}`;
            const isBookmarked = BookmarkManager.isBookmarked(window.currentState.threadId, post.post_number);
            if(isBookmarked) div.classList.add('bookmarked');
            const formattedDate = parseUTCDate(post.created_at)?.toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
            div.innerHTML = `<div class="post-header"><span class="post-header-main"><span class="post-number">${post.post_number}</span>: ${escapeHTML(post.author || '名無しさん')}</span><span class="post-date">${formattedDate}</span></div><div class="post-body">${escapeHTML(post.body).replace(/\n/g, '<br>')}</div>`;
            div.querySelector('.post-header').addEventListener('click', (e) => {
                e.stopPropagation();
                const isNowBookmarked = BookmarkManager.toggle(window.currentState.threadId, window.currentState.threadInfo.title, post);
                updateBookmarkStyle(post.post_number, isNowBookmarked);
                if (bookmarkModal.style.display === 'flex') { const currentTid = bookmarkViewContent.dataset.currentTid; prepareBookmarkView(currentTid === 'null' ? null : currentTid); }
            });
            fragment.appendChild(div);
        });
        const firstPost = postsContainer.querySelector('.post');
        if (firstPost && !clear) { postsContainer.insertBefore(fragment, firstPost); } else { postsContainer.appendChild(fragment); }
        updateOlderPostsLoaderVisibility();
    };

    const updateOlderPostsLoaderVisibility = () => {
        const firstPostNum = window.currentState.posts[0]?.post_number;
        const loaderBtn = postsLoader.querySelector('.load-older-btn');
        if (firstPostNum > 1) { if (!loaderBtn) { postsLoader.insertAdjacentHTML('afterbegin', `<button class="load-older-btn" onclick="loadOlderPosts(this)">前のレス${POSTS_PER_PAGE}件を表示</button>`); } } else { if (loaderBtn) loaderBtn.remove(); }
    };
    window.loadOlderPosts = async (button) => {
        if (isLoadingPosts) return;
        isLoadingPosts = true; button.disabled = true; button.textContent = '読み込み中...';
        try {
            const firstPostNum = window.currentState.posts[0].post_number;
            const currentChunk = Math.floor((firstPostNum - 1) / CHUNK_SIZE);
            const chunksNeeded = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const startChunk = Math.max(0, currentChunk - chunksNeeded);
            const chunksToFetch = Array.from({length: currentChunk - startChunk}, (_, i) => startChunk + i);
            const olderPosts = await fetchPostChunks(chunksToFetch);
            if(olderPosts.length > 0) { const currentTopPost = postsContainer.querySelector('.post'); window.currentState.posts.unshift(...olderPosts); window.currentState.posts.sort((a,b) => a.post_number - b.post_number); renderPosts(true); document.getElementById(currentTopPost.id)?.scrollIntoView(); }
        } catch(error) { console.error(error); button.textContent = '読み込み失敗'; } finally { isLoadingPosts = false; }
    };
    window.loadMorePosts = async (button, startChunk) => {
        if (isLoadingPosts) return;
        isLoadingPosts = true; button.disabled = true; button.textContent = '読み込み中...';
        try {
            const chunksNeeded = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const endChunk = startChunk + chunksNeeded - 1;
            const chunksToFetch = Array.from({length: endChunk - startChunk + 1}, (_, i) => startChunk + i);
            const morePosts = await fetchPostChunks(chunksToFetch);
            if (morePosts.length > 0) { window.currentState.posts.push(...morePosts); window.currentState.posts.sort((a,b) => a.post_number - b.post_number); renderPosts(true); }
            const remainingPosts = window.currentState.threadInfo.post_count - ((endChunk + 1) * CHUNK_SIZE);
            if (remainingPosts > 0) { button.textContent = `続きから読む (${remainingPosts}レス)`; button.onclick = () => loadMorePosts(button, endChunk + 1); button.disabled = false; } else { button.remove(); }
        } catch(error) { console.error(error); button.textContent = '読み込み失敗'; } finally { isLoadingPosts = false; }
    };
    
    // --- Bookmark Modal Logic (変更なし) ---
    const updateBookmarkStyle = (postNumber, isBookmarked) => {
        const postEl = document.getElementById(`post-${postNumber}`);
        if(postEl) { postEl.classList.toggle('bookmarked', isBookmarked); }
    };
    window.openBookmarkModal = () => { prepareBookmarkView(null); bookmarkModal.style.display = 'flex'; };
    window.closeBookmarkModal = () => { bookmarkModal.style.display = 'none'; };
    const prepareBookmarkView = (threadId) => {
        bookmarkViewContent.innerHTML = ''; bookmarkViewContent.dataset.currentTid = threadId ?? 'null'; const allBookmarks = BookmarkManager.getAll();
        if (threadId) {
            const threadData = allBookmarks[threadId];
            const title = document.createElement('h3'); title.textContent = `栞: ${escapeHTML(threadData?.title || '不明なスレッド')}`;
            const backBtn = document.createElement('button'); backBtn.className = 'back-button'; backBtn.textContent = '« 栞一覧に戻る'; backBtn.onclick = () => prepareBookmarkView(null);
            bookmarkViewContent.append(backBtn, title);
            if (threadData && Object.keys(threadData.bookmarks).length > 0) { Object.entries(threadData.bookmarks).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).forEach(([postNumber, bookmark]) => { const item = document.createElement('div'); item.className = 'bookmark-item'; item.innerHTML = `<div style="flex-grow: 1;"><strong>レス ${postNumber}</strong><div class="post-body">${escapeHTML(bookmark.content)}</div></div><button class="bookmark-delete-btn">削除</button>`; item.querySelector('.bookmark-delete-btn').onclick = (e) => { e.stopPropagation(); BookmarkManager.removeSingle(threadId, postNumber); updateBookmarkStyle(postNumber, false); prepareBookmarkView(threadId); }; item.onclick = () => jumpToBookmark(threadId, postNumber); bookmarkViewContent.appendChild(item); }); } else { bookmarkViewContent.insertAdjacentHTML('beforeend', '<p>このスレッドの栞はありません。</p>'); }
        } else {
            const title = document.createElement('h3'); title.textContent = '栞一覧'; bookmarkViewContent.appendChild(title);
            if (Object.keys(allBookmarks).length > 0) {
                Object.entries(allBookmarks).forEach(([tid, threadData]) => {
                    const newestBookmark = Object.entries(threadData.bookmarks).sort((a,b) => parseInt(b[0]) - parseInt(a[0]))[0];
                    if (!newestBookmark) return;
                    const [postNumber, bookmark] = newestBookmark;
                    
                    const rawContent = bookmark.content;
                    const summary = rawContent.length > 10 ? rawContent.substring(0, 10) + '...' : rawContent;
                    const summaryContent = escapeHTML(summary);

                    const item = document.createElement('div');
                    item.className = 'bookmark-item';
                    item.innerHTML = `<div style="flex-grow: 1;"><div><strong>${escapeHTML(threadData.title)}</strong></div><div class="post-summary">レス ${postNumber} ${summaryContent}</div></div><div style="text-align: right; display: flex; flex-direction: column; gap: 5px;"><button class="view-thread-bookmarks-btn">全件表示</button><button class="bookmark-delete-btn">全削除</button></div>`;
                    
                    item.querySelector('.view-thread-bookmarks-btn').onclick = (e) => { e.stopPropagation(); prepareBookmarkView(tid); };
                    item.querySelector('.bookmark-delete-btn').onclick = (e) => { e.stopPropagation(); if (confirm(`「${threadData.title}」の栞をすべて削除しますか？`)) { BookmarkManager.removeForThread(tid); prepareBookmarkView(); if(window.currentState.threadId === tid) { window.currentState.posts.forEach(p => updateBookmarkStyle(p.post_number, false)); } } };
                    item.onclick = () => jumpToBookmark(tid, postNumber);
                    bookmarkViewContent.appendChild(item);
                });
            } else { bookmarkViewContent.insertAdjacentHTML('beforeend', '<p>栞はまだありません。</p>'); }
        }
    };
    const jumpToBookmark = (threadId, postNumber) => {
        const autoDelete = autoDeleteBookmarkCheckbox.checked;
        if (autoDelete) { BookmarkManager.removeSingle(threadId, postNumber); if (window.currentState.threadId === threadId) { updateBookmarkStyle(postNumber, false); } }
        closeBookmarkModal();
        const currentRoute = parsePath();
        const genre = (currentRoute.view === 'threadContent' || currentRoute.view === 'threadList') ? currentRoute.genre : 'unknown';
        history.pushState({ jumpToPostNumber: parseInt(postNumber, 10) }, '', `/${genre}/${threadId}`);
        router();
    };

    // --- Event Handlers & Form Submissions ---
    document.querySelector('header h1 a').onclick = (e) => { e.preventDefault(); navigate('/'); };
    backToHomeBtnHeader.onclick = () => navigate('/');
    backToThreadListBtnHeader.onclick = () => navigate(`/${window.currentState.genre}`);
    window.addEventListener('popstate', router);
    
    const newThreadForm = document.getElementById('new-thread-form');
    const writePermissionRadios = newThreadForm.querySelectorAll('input[name="write_permission"]');
    const nameSettingRadios = newThreadForm.querySelectorAll('input[name="name_setting"]');
    const fixedNameInput = document.getElementById('fixed_name_input');
    const accountLinkedRadio = newThreadForm.querySelector('input[value="account_linked"]');

    writePermissionRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            if (e.target.value === 'authenticated') {
                accountLinkedRadio.disabled = false;
            } else {
                accountLinkedRadio.disabled = true;
                if (accountLinkedRadio.checked) {
                    newThreadForm.querySelector('input[value="user_choice"]').checked = true;
                }
            }
        });
    });
    nameSettingRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
            fixedNameInput.disabled = (e.target.value !== 'fixed');
        });
    });

    document.getElementById('new-thread-form').addEventListener('submit', async (e) => {
        e.preventDefault(); const idToken = window.authState.idToken; const headers = { 'Content-Type': 'application/json' }; if (idToken) headers['Authorization'] = `Bearer ${idToken}`; const form = e.target, btn = form.querySelector('button'), genre = form.elements['new-thread-genre'].value; btn.disabled = true;
        try { 
            const write_permission = form.elements['write_permission'].value;
            const name_setting = form.elements['name_setting'].value;
            const fixed_name = form.elements['fixed_name_input'].value;

            const res = await fetch('/api/threads', { method: 'POST', headers, body: JSON.stringify({ genre, title: form.elements['new-thread-title'].value, author: form.elements['new-thread-author'].value, body: form.elements['new-thread-body'].value, write_permission, name_setting, fixed_name }) }); 
            if (!res.ok) await handleApiError(res); 
            navigate(`/${genre}`);
        } catch(err) { console.error(err); alert(err.message); } finally { btn.disabled = false; }
    });
    document.getElementById('new-post-form').addEventListener('submit', async (e) => {
        e.preventDefault(); const idToken = window.authState.idToken; const headers = { 'Content-Type': 'application/json' }; if (idToken) headers['Authorization'] = `Bearer ${idToken}`; const form = e.target, btn = form.querySelector('button'), threadId = form.elements['current-thread-id'].value; btn.disabled = true;
        try { const res = await fetch(`/api/threads/${threadId}/posts`, { method: 'POST', headers, body: JSON.stringify({ author: form.elements['new-post-author'].value, body: form.elements['new-post-body'].value }) }); if (!res.ok) await handleApiError(res); 
            form.elements['new-post-body'].value = '';
            await prepareThreadContentView(threadId); 
        } catch(err) { console.error(err); alert(err.message); } finally { btn.disabled = false; }
    });

    // --- Initial Load ---
    router();
});
</script>
</body>
</html>