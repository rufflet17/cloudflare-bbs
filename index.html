<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cloudflare BBS</title>
  <style>
    /* (CSS„ÅØÂ§âÊõ¥„Å™„Åó) */
    :root {
      --font-classic: 'MS PGothic', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
      --font-modern: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Hiragino Sans', 'Noto Sans CJK JP', 'Noto Sans JP', sans-serif;
    }
    body[data-theme="classic"] {
      --font-family: var(--font-classic); --bg-color: #efefef; --main-bg-color: #fff; --text-color: #333; --header-bg-color: #ddd; --border-color: #ccc; --accent-color: #99c; --link-color: #007bff; --link-hover-color: #0056b3; --post-name-color: #006400; --post-meta-color: #555; --post-border-color: #eee; --thread-hover-bg: #f0f8ff; --card-radius: 0px; --card-shadow: none;
    }
    body[data-theme="modern"] {
      --font-family: var(--font-modern); --bg-color: #f4f7f9; --main-bg-color: #ffffff; --text-color: #2c3e50; --header-bg-color: #ffffff; --border-color: #e0e6ed; --accent-color: #3498db; --link-color: #3498db; --link-hover-color: #2980b9; --post-name-color: #27ae60; --post-meta-color: #7f8c8d; --post-border-color: transparent; --thread-hover-bg: #ecf5ff; --card-radius: 8px; --card-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }
    body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); margin: 0; transition: background-color 0.2s, color 0.2s; }
    header { background-color: var(--header-bg-color); padding: 10px; border-bottom: 1px solid var(--border-color); box-shadow: var(--card-shadow); position: sticky; top: 0; z-index: 10; }
    .header-content { max-width: 800px; margin: 0 auto; display: flex; justify-content: space-between; align-items: center; }
    .header-left, .header-right { display: flex; align-items: center; gap: 10px; flex: 1; }
    .header-right { justify-content: flex-end; }
    .header-content h1 { margin: 0; font-size: 1.5em; flex: 2; text-align: center; }
    .header-nav-btn, #auth-controls-header button { padding: 5px 10px; font-size: 0.9em; }
    #auth-controls-header { display: flex; align-items: center; gap: 5px; }
    main { max-width: 800px; margin: 20px auto; background-color: var(--main-bg-color); padding: 20px; border: 1px solid var(--border-color); border-radius: var(--card-radius); }
    h2, h3 { border-bottom: 2px solid var(--accent-color); padding-bottom: 5px; }
    form { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
    input, textarea, select { padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; font-family: inherit; font-size: 1em; background-color: var(--bg-color); color: var(--text-color); }
    input:focus, textarea:focus, select:focus { outline: none; border-color: var(--link-color); box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2); }
    button { padding: 10px; background-color: var(--link-color); color: white; border: none; cursor: pointer; border-radius: 4px; font-size: 1em; font-weight: bold; transition: background-color 0.2s; }
    button:hover { background-color: var(--link-hover-color); }
    button:disabled { background-color: #6c757d; cursor: not-allowed; }
    .theme-switcher { margin-bottom: 10px; text-align: right; }
    .theme-switcher button { padding: 5px 10px; font-size: 0.8em; margin-left: 5px; background-color: #ccc; color: #333; font-weight: normal; }
    .theme-switcher button.active { background-color: var(--link-color); color: white; }
    .list-item, #thread-list .thread-item { cursor: pointer; padding: 10px; border-bottom: 1px dotted var(--border-color); display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; text-decoration: none; color: inherit; }
    .list-item:hover, #thread-list .thread-item:hover { background-color: var(--thread-hover-bg); }
    .thread-details { flex-grow: 1; }
    .thread-meta { font-size: 0.8em; color: #666; text-align: right; white-space: nowrap; }
    .post { margin-bottom: 15px; padding-left: 10px; border-left: 3px solid var(--post-border-color); transition: background-color 0.2s, border-color 0.2s; }
    .post-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.9em; color: var(--post-name-color); font-weight: bold; cursor: pointer; }
    .post-header-main { display: flex; align-items: center; }
    .post-header .post-date { color: var(--post-meta-color); font-weight: normal; margin-left: 10px; }
    .post-body { margin-left: 1em; line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; }
    .post-number { text-decoration: underline; }
    .bookmark-icon { margin-left: 5px; color: var(--accent-color); font-style: normal; }
    .post.bookmarked { background-color: var(--thread-hover-bg); border-left-color: var(--accent-color); }
    body[data-theme="modern"] .post { border-left: none; padding: 15px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 6px; }
    body[data-theme="modern"] .post-body { margin-left: 0; }
    body[data-theme="modern"] .post.bookmarked { border: 1px solid var(--accent-color); background-color: var(--thread-hover-bg); box-shadow: 0 1px 4px rgba(52, 152, 219, 0.2); }
    #posts-loader { text-align: center; margin-bottom: 15px; }
    .view { display: none; }
    
    /* --- Ê†û„É¢„Éº„ÉÄ„É´„ÅÆ„Çπ„Çø„Ç§„É´ÔºàÊú¨„ÅÆ„Çà„ÅÜ„Å´Ôºâ --- */
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
    .modal-content {
        background-color: #fdf6e3; color: #586e75; font-family: 'Georgia', 'Yu Mincho', 'Hiragino Mincho ProN', serif;
        width: 90%; max-width: 800px; height: 80vh; max-height: 600px;
        padding: 40px 50px 60px 50px; border: 1px solid #d3c2a5; border-radius: 2px 10px 10px 2px;
        box-shadow: -10px 10px 15px rgba(0, 0, 0, 0.3), inset 0 0 20px rgba(0, 0, 0, 0.1);
        position: relative; overflow-y: auto;
    }
    .modal-content::before { content: ''; position: absolute; top: 0; left: 50%; width: 30px; height: 100%; transform: translateX(-50%); background: linear-gradient(to right, rgba(0,0,0,0) 0%, rgba(0,0,0,0.15) 45%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.15) 55%, rgba(0,0,0,0) 100%); pointer-events: none; border-radius: inherit; }
    .modal-content::after { content: ''; position: absolute; top: -2px; left: 58%; width: 15px; height: 60px; background-color: #b52a32; border: 1px solid rgba(0,0,0,0.2); border-top: none; border-bottom-left-radius: 8px; border-bottom-right-radius: 8px; box-shadow: 0 3px 5px rgba(0,0,0,0.2); z-index: 1; }
    .modal-close { position: absolute; top: 10px; right: 15px; font-size: 2em; line-height: 1; background: none; border: none; color: #839496; cursor: pointer; z-index: 2; transition: color 0.2s; }
    .modal-close:hover { color: #002b36; }
    #bookmark-view-content h3 { text-align: center; font-size: 1.5em; border-bottom: 2px solid #b58900; padding-bottom: 15px; margin-bottom: 25px; color: #657b83; }
    #bookmark-view-content .bookmark-item { border-bottom: 1px dashed #d3c2a5; padding: 15px 5px; cursor: pointer; transition: background-color 0.2s; display: flex; justify-content: space-between; align-items: center; }
    #bookmark-view-content .bookmark-item:hover { background-color: rgba(181, 137, 0, 0.08); }
    #bookmark-view-content .post-summary, #bookmark-view-content .post-body { color: #657b83; font-size: 0.95em; }
    #bookmark-view-content .post-summary { margin-top: 4px; }
    #bookmark-view-content .post-body { max-height: 3.2em; overflow: hidden; }
    #bookmark-view-content button { font-family: var(--font-modern); font-size: 0.8em; padding: 4px 8px; border: 1px solid #b58900; background-color: transparent; color: #b58900; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    #bookmark-view-content button:hover { background-color: #b58900; color: #fdf6e3; }
    #bookmark-view-content .back-button { margin-bottom: 15px !important; }
    #bookmark-view-content .bookmark-delete-btn { border-color: #dc3545; color: #dc3545; }
    #bookmark-view-content .bookmark-delete-btn:hover { background-color: #dc3545; color: #fff; }
    #bookmark-options { position: absolute; bottom: 15px; left: 50px; font-size: 0.9em; color: #657b83; z-index: 2; }
    #bookmark-options label { display: flex; align-items: center; gap: 5px; cursor: pointer; }
    #bookmark-options input { width: auto; padding: 0; margin: 0; }
  </style>
</head>
<body data-theme="classic">

  <header>
    <div class="header-content">
      <div class="header-left">
        <button id="back-to-home-btn-header" class="header-nav-btn" style="display: none;">&laquo; „Ç∏„É£„É≥„É´‰∏ÄË¶ß</button>
        <button id="back-to-thread-list-btn-header" class="header-nav-btn" style="display: none;">&laquo; „Çπ„É¨„ÉÉ„Éâ‰∏ÄË¶ß</button>
      </div>
      <h1><a href="/" style="text-decoration: none; color: inherit;">Cloudflare BBS</a></h1>
      <div class="header-right">
        <button id="open-bookmarks-header" class="header-nav-btn" onclick="openBookmarkModal()">Ê†û</button>
        <div id="auth-controls-header">
            <span id="user-display"></span>
            <button id="login-btn" onclick="login()">„É≠„Ç∞„Ç§„É≥</button>
            <button id="logout-btn" onclick="logout()" style="display:none;">„É≠„Ç∞„Ç¢„Ç¶„Éà</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <div class="theme-switcher">
        <button data-theme="classic">„ÇØ„É©„Ç∑„ÉÉ„ÇØ</button>
        <button data-theme="modern">„É¢„ÉÄ„É≥</button>
    </div>
    <div id="home-view" class="view"><h2>„Ç∏„É£„É≥„É´‰∏ÄË¶ß</h2><div id="genre-list"></div></div>
    <div id="thread-list-view" class="view">
      <h2 id="thread-list-title"></h2>
      <div id="thread-list"></div><hr><h3>Êñ∞„Åó„ÅÑ„Çπ„É¨„ÉÉ„Éâ„ÇíÁ´ã„Å¶„Çã</h3>
      <form id="new-thread-form"><input type="hidden" id="new-thread-genre"><input type="text" id="new-thread-title" placeholder="„Çπ„É¨„ÉÉ„Éâ„Çø„Ç§„Éà„É´" required><input type="text" id="new-thread-author" placeholder="ÂêçÂâç (ÁúÅÁï•ÂèØ)"><textarea id="new-thread-body" placeholder="ÊúÄÂàù„ÅÆÊõ∏„ÅçËæº„Åø" rows="4" required></textarea><button type="submit">„Çπ„É¨„ÉÉ„Éâ‰ΩúÊàê</button></form>
    </div>
    <div id="thread-content-view" class="view">
      <h2 id="thread-title"></h2>
      <div id="posts-loader"></div><div id="posts-container"></div><hr><h3>„É¨„Çπ„ÇíÊõ∏„ÅçËæº„ÇÄ</h3>
      <form id="new-post-form"><input type="hidden" id="current-thread-id"><input type="text" id="new-post-author" placeholder="ÂêçÂâç (ÁúÅÁï•ÂèØ)"><textarea id="new-post-body" placeholder="Êõ∏„ÅçËæº„ÅøÂÜÖÂÆπ" rows="4" required></textarea><button type="submit">Êõ∏„ÅçËæº„ÇÄ</button></form>
    </div>
  </main>

  <!-- Ê†û„É¢„Éº„ÉÄ„É´ -->
  <div id="bookmark-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <button class="modal-close" onclick="closeBookmarkModal()">√ó</button>
      <div id="bookmark-view-content"></div>
      <div id="bookmark-options">
        <label>
          <input type="checkbox" id="auto-delete-bookmark-checkbox">
          „Ç∏„É£„É≥„ÉóÂæå„Å´Ê†û„ÇíËá™ÂãïÂâäÈô§„Åô„Çã
        </label>
      </div>
    </div>
  </div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
  const firebaseConfig = {"apiKey":"AIzaSyDSfTZRS0Smjnxns4hEzDibrY9dDIEMpgQ","authDomain":"thread-fb369.firebaseapp.com","projectId":"thread-fb369","storageBucket":"thread-fb369.firebasestorage.app","messagingSenderId":"259512543030","appId":"1:259512543030:web:cb6674ae37384371c0b597","measurementId":"G-2EWG4EWCQR"};
  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const provider = new GoogleAuthProvider();
  window.authState = { user: null, idToken: null };
  onAuthStateChanged(auth, async (user) => {
    const userDisplay = document.getElementById('user-display');
    const loginBtn = document.getElementById('login-btn');
    const logoutBtn = document.getElementById('logout-btn');
    const newThreadAuthorInput = document.getElementById('new-thread-author');
    const newPostAuthorInput = document.getElementById('new-post-author');
    if (user) {
      window.authState.user = user;
      window.authState.idToken = await user.getIdToken(true);
      userDisplay.textContent = `${user.displayName} „Åï„Çì`;
      loginBtn.style.display = 'none';
      logoutBtn.style.display = 'inline';
      if(newThreadAuthorInput) { newThreadAuthorInput.value = user.displayName; newThreadAuthorInput.readOnly = true; }
      if(newPostAuthorInput) { newPostAuthorInput.value = user.displayName; newPostAuthorInput.readOnly = true; }
    } else {
      window.authState.user = null;
      window.authState.idToken = null;
      userDisplay.textContent = '';
      loginBtn.style.display = 'inline';
      logoutBtn.style.display = 'none';
      if(newThreadAuthorInput) { newThreadAuthorInput.value = ''; newThreadAuthorInput.readOnly = false; newThreadAuthorInput.placeholder = "ÂêçÂâç (ÁúÅÁï•ÂèØ)"; }
      if(newPostAuthorInput) { newPostAuthorInput.value = ''; newPostAuthorInput.readOnly = false; newPostAuthorInput.placeholder = "ÂêçÂâç (ÁúÅÁï•ÂèØ)"; }
    }
  });
  window.login = async () => { try { await signInWithPopup(auth, provider); } catch (error) { console.error("„É≠„Ç∞„Ç§„É≥„Ç®„É©„Éº:", error); } };
  window.logout = async () => { await signOut(auth); };
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Ë®≠ÂÆöÂÄ§ ---
    const CHUNK_SIZE = 50;
    const POSTS_PER_PAGE = 200;

    let currentState = {};
    let isLoadingPosts = false;

    // --- DOM Elements ---
    const views = { home: document.getElementById('home-view'), threadList: document.getElementById('thread-list-view'), threadContent: document.getElementById('thread-content-view') };
    const genreListContainer = document.getElementById('genre-list');
    const threadListContainer = document.getElementById('thread-list');
    const postsContainer = document.getElementById('posts-container');
    const postsLoader = document.getElementById('posts-loader');
    const bookmarkModal = document.getElementById('bookmark-modal');
    const bookmarkViewContent = document.getElementById('bookmark-view-content');
    const backToHomeBtnHeader = document.getElementById('back-to-home-btn-header');
    const backToThreadListBtnHeader = document.getElementById('back-to-thread-list-btn-header');
    const autoDeleteBookmarkCheckbox = document.getElementById('auto-delete-bookmark-checkbox');
    
    // --- Bookmark Manager ---
    const BookmarkManager = {
        key: 'bbs_bookmarks',
        getAll: () => JSON.parse(localStorage.getItem(BookmarkManager.key) || '{}'),
        saveAll: (data) => localStorage.setItem(BookmarkManager.key, JSON.stringify(data)),
        toggle: (threadId, threadTitle, post) => {
            const allData = BookmarkManager.getAll();
            if (!allData[threadId]) { allData[threadId] = { title: threadTitle, bookmarks: {} }; }
            const threadBookmarks = allData[threadId].bookmarks;
            if (threadBookmarks[post.post_number]) { delete threadBookmarks[post.post_number]; } 
            else { threadBookmarks[post.post_number] = { content: post.body }; }
            if (Object.keys(threadBookmarks).length === 0) { delete allData[threadId]; }
            BookmarkManager.saveAll(allData);
            return !!threadBookmarks[post.post_number];
        },
        isBookmarked: (threadId, postNumber) => {
            const threadData = BookmarkManager.getAll()[threadId];
            return !!(threadData && threadData.bookmarks[postNumber]);
        },
        removeForThread: (threadId) => {
            const allData = BookmarkManager.getAll();
            delete allData[threadId];
            BookmarkManager.saveAll(allData);
        },
        removeSingle: (threadId, postNumber) => {
             const allData = BookmarkManager.getAll();
             if(allData[threadId] && allData[threadId].bookmarks[postNumber]) {
                 delete allData[threadId].bookmarks[postNumber];
                 if (Object.keys(allData[threadId].bookmarks).length === 0) { delete allData[threadId]; }
                 BookmarkManager.saveAll(allData);
             }
        }
    };

    // --- Bookmark Auto-Delete Option ---
    const AUTO_DELETE_KEY = 'bbs_auto_delete_bookmark';
    const initAutoDeleteOption = () => {
        const savedValue = localStorage.getItem(AUTO_DELETE_KEY) === 'true';
        autoDeleteBookmarkCheckbox.checked = savedValue;
        autoDeleteBookmarkCheckbox.addEventListener('change', (e) => {
            localStorage.setItem(AUTO_DELETE_KEY, e.target.checked);
        });
    };
    initAutoDeleteOption();

    // --- Theme Switcher ---
    const themeSwitcher = document.querySelector('.theme-switcher');
    const themeButtons = themeSwitcher.querySelectorAll('button');
    const applyTheme = (theme) => {
        document.body.setAttribute('data-theme', theme);
        themeButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.theme === theme));
        localStorage.setItem('theme', theme);
    };
    themeSwitcher.addEventListener('click', (e) => (e.target.tagName === 'BUTTON') && applyTheme(e.target.dataset.theme));
    applyTheme(localStorage.getItem('theme') || 'classic');

    // --- Helper Functions ---
    const escapeHTML = (str) => str.replace(/[&<>"']/g, (match) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]));
    async function handleApiError(response) { try { const d = await response.json(); throw new Error(d.error || '‰∏çÊòé„Å™„Ç®„É©„Éº'); } catch (e) { throw new Error('„Çµ„Éº„Éê„ÉºÈÄö‰ø°Â§±Êïó'); } }
    const parseUTCDate = (dateString) => dateString ? new Date(dateString.replace(' ', 'T') + 'Z') : null;

    // --- Navigation & Router ---
    window.navigate = (path) => { history.pushState(null, '', path); router(); };
    const parsePath = () => {
        const parts = window.location.pathname.split('/').filter(p => p);
        if (parts.length === 2) return { view: 'threadContent', genre: parts[0], threadId: parts[1] };
        if (parts.length === 1) return { view: 'threadList', genre: parts[0] };
        return { view: 'home' };
    };
    const updateHeaderButtons = (view) => {
        backToHomeBtnHeader.style.display = (view === 'threadList') ? 'inline-block' : 'none';
        backToThreadListBtnHeader.style.display = (view === 'threadContent') ? 'inline-block' : 'none';
    };
    const router = async () => {
        const route = parsePath();
        const jumpToPostNumber = history.state?.jumpToPostNumber;
        history.replaceState(null, '', window.location.pathname); 

        currentState = { ...route, jumpToPostNumber };
        let nextView;
        try {
            switch (route.view) {
                case 'threadContent': await prepareThreadContentView(route.threadId, jumpToPostNumber); nextView = views.threadContent; break;
                case 'threadList': await prepareThreadListView(route.genre); nextView = views.threadList; break;
                default: await prepareHomeView(); nextView = views.home; break;
            }
            Object.values(views).forEach(v => v.style.display = 'none');
            if (nextView) nextView.style.display = 'block';
            updateHeaderButtons(route.view);
        } catch (error) { console.error(error); alert(error.message); }
    };

    // --- View Preparation Functions ---
    const prepareHomeView = async () => {
        const res = await fetch('/api/genres', { cache: 'no-cache' });
        if (!res.ok) await handleApiError(res);
        const genres = await res.json();
        genreListContainer.innerHTML = '';
        if (genres && genres.length > 0) { genres.forEach(({ genre }) => { const a = document.createElement('a'); a.href = `/${genre}`; a.className = 'list-item'; a.innerHTML = `<strong>${escapeHTML(genre)}</strong>`; a.onclick = (e) => { e.preventDefault(); navigate(`/${genre}`); }; genreListContainer.appendChild(a); }); } else { genreListContainer.innerHTML = '<p>„Ç∏„É£„É≥„É´„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>'; }
    };
    const prepareThreadListView = async (genre) => {
        const res = await fetch(`/api/threads?genre=${genre}`, { cache: 'no-cache' });
        if (!res.ok) await handleApiError(res);
        const threads = await res.json();
        document.getElementById('thread-list-title').textContent = `${escapeHTML(genre)} „ÅÆ„Çπ„É¨„ÉÉ„Éâ‰∏ÄË¶ß`;
        document.getElementById('new-thread-genre').value = genre;
        threadListContainer.innerHTML = '';
        if (threads && threads.length > 0) { threads.forEach(thread => { const a = document.createElement('a'); a.href = `/${genre}/${thread.id}`; a.className = 'thread-item'; const lastUpdatedDate = parseUTCDate(thread.last_updated); const formattedDate = lastUpdatedDate.toLocaleString('ja-JP', { year: '2-digit', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }); a.innerHTML = `<div class="thread-details"><strong>${escapeHTML(thread.title)}</strong></div><div class="thread-meta">„É¨„Çπ: ${thread.post_count}<br>Êõ¥Êñ∞: ${formattedDate}</div>`; a.onclick = (e) => { e.preventDefault(); navigate(`/${genre}/${thread.id}`); }; threadListContainer.appendChild(a); }); } else { threadListContainer.innerHTML = '<p>„Çπ„É¨„ÉÉ„Éâ„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>'; }
    };
    const prepareThreadContentView = async (threadId, jumpToPostNumber = null) => {
        postsContainer.innerHTML = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
        postsLoader.innerHTML = '';
        const infoRes = await fetch(`/api/threads/${threadId}/info`, { cache: 'no-cache' });
        if (!infoRes.ok) await handleApiError(infoRes);
        const threadInfo = await infoRes.json();
        currentState = { ...currentState, threadInfo, threadId, posts: [], loadedChunks: new Set() };
        document.getElementById('thread-title').textContent = threadInfo.title;
        document.getElementById('current-thread-id').value = threadInfo.id;
        let initialPosts = [];
        if (jumpToPostNumber) {
            const targetChunk = Math.floor((jumpToPostNumber - 1) / CHUNK_SIZE);
            const chunksNeeded = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const endChunk = targetChunk + chunksNeeded - 1;
            const chunksToFetch = Array.from({length: endChunk - targetChunk + 1}, (_, i) => targetChunk + i);
            initialPosts = await fetchPostChunks(chunksToFetch);
            const remainingPosts = threadInfo.post_count - ((endChunk + 1) * CHUNK_SIZE);
            if (remainingPosts > 0) { postsLoader.insertAdjacentHTML('beforeend', `<button onclick="loadMorePosts(this, ${endChunk + 1})">Á∂ö„Åç„Åã„ÇâË™≠„ÇÄ (${remainingPosts}„É¨„Çπ)</button>`); }
        } else {
            const latestChunk = Math.floor((threadInfo.post_count - 1) / CHUNK_SIZE);
            const chunksNeeded = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const startChunk = Math.max(0, latestChunk - chunksNeeded + 1);
            const chunksToFetch = Array.from({length: latestChunk - startChunk + 1}, (_, i) => startChunk + i);
            initialPosts = await fetchPostChunks(chunksToFetch);
        }
        currentState.posts = initialPosts.sort((a,b) => a.post_number - b.post_number);
        renderPosts(true);
        if (jumpToPostNumber) { setTimeout(() => document.getElementById(`post-${jumpToPostNumber}`)?.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100); }
    };
    
    // --- Post Rendering & Loading ---
    const fetchPostChunks = async (chunkNumbers) => {
        const chunksToFetch = chunkNumbers.filter(cn => !currentState.loadedChunks.has(cn));
        if (chunksToFetch.length === 0) return [];
        const promises = chunksToFetch.map(i => { currentState.loadedChunks.add(i); return fetch(`/api/threads/${currentState.threadId}/posts?chunk=${i}`, { cache: 'no-cache' }).then(res => res.json()); });
        return (await Promise.all(promises)).flat();
    };
    
    const renderPosts = (clear = true) => {
        if(clear) postsContainer.innerHTML = '';
        const fragment = document.createDocumentFragment();
        currentState.posts.forEach(post => {
            if (document.getElementById(`post-${post.post_number}`)) return;
            const div = document.createElement('div');
            div.className = 'post';
            div.id = `post-${post.post_number}`;
            const isBookmarked = BookmarkManager.isBookmarked(currentState.threadId, post.post_number);
            if(isBookmarked) div.classList.add('bookmarked');
            const formattedDate = parseUTCDate(post.created_at)?.toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
            div.innerHTML = `<div class="post-header"><span class="post-header-main"><span class="post-number">${post.post_number}</span>: ${escapeHTML(post.author || 'ÂêçÁÑ°„Åó„Åï„Çì')}<i class="bookmark-icon">${isBookmarked ? 'üîñ' : 'üìé'}</i></span><span class="post-date">${formattedDate}</span></div><div class="post-body">${escapeHTML(post.body).replace(/\n/g, '<br>')}</div>`;
            div.querySelector('.post-header').addEventListener('click', (e) => {
                e.stopPropagation();
                const isNowBookmarked = BookmarkManager.toggle(currentState.threadId, currentState.threadInfo.title, post);
                updateBookmarkStyle(post.post_number, isNowBookmarked);
                if (bookmarkModal.style.display === 'flex') { const currentTid = bookmarkViewContent.dataset.currentTid; prepareBookmarkView(currentTid === 'null' ? null : currentTid); }
            });
            fragment.appendChild(div);
        });
        const firstPost = postsContainer.querySelector('.post');
        if (firstPost && !clear) { postsContainer.insertBefore(fragment, firstPost); } else { postsContainer.appendChild(fragment); }
        updateOlderPostsLoaderVisibility();
    };

    const updateOlderPostsLoaderVisibility = () => {
        const firstPostNum = currentState.posts[0]?.post_number;
        const loaderBtn = postsLoader.querySelector('.load-older-btn');
        if (firstPostNum > 1) { if (!loaderBtn) { postsLoader.insertAdjacentHTML('afterbegin', `<button class="load-older-btn" onclick="loadOlderPosts(this)">Ââç„ÅÆ„É¨„Çπ${POSTS_PER_PAGE}‰ª∂„ÇíË°®Á§∫</button>`); } } else { if (loaderBtn) loaderBtn.remove(); }
    };
    window.loadOlderPosts = async (button) => {
        if (isLoadingPosts) return;
        isLoadingPosts = true; button.disabled = true; button.textContent = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
        try {
            const firstPostNum = currentState.posts[0].post_number;
            const currentChunk = Math.floor((firstPostNum - 1) / CHUNK_SIZE);
            const chunksNeeded = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const startChunk = Math.max(0, currentChunk - chunksNeeded);
            const chunksToFetch = Array.from({length: currentChunk - startChunk}, (_, i) => startChunk + i);
            const olderPosts = await fetchPostChunks(chunksToFetch);
            if(olderPosts.length > 0) { const currentTopPost = postsContainer.querySelector('.post'); currentState.posts.unshift(...olderPosts); currentState.posts.sort((a,b) => a.post_number - b.post_number); renderPosts(true); document.getElementById(currentTopPost.id)?.scrollIntoView(); }
        } catch(error) { console.error(error); button.textContent = 'Ë™≠„ÅøËæº„ÅøÂ§±Êïó'; } finally { isLoadingPosts = false; }
    };
    window.loadMorePosts = async (button, startChunk) => {
        if (isLoadingPosts) return;
        isLoadingPosts = true; button.disabled = true; button.textContent = 'Ë™≠„ÅøËæº„Åø‰∏≠...';
        try {
            const chunksNeeded = Math.ceil(POSTS_PER_PAGE / CHUNK_SIZE);
            const endChunk = startChunk + chunksNeeded - 1;
            const chunksToFetch = Array.from({length: endChunk - startChunk + 1}, (_, i) => startChunk + i);
            const morePosts = await fetchPostChunks(chunksToFetch);
            if (morePosts.length > 0) { currentState.posts.push(...morePosts); currentState.posts.sort((a,b) => a.post_number - b.post_number); renderPosts(true); }
            const remainingPosts = currentState.threadInfo.post_count - ((endChunk + 1) * CHUNK_SIZE);
            if (remainingPosts > 0) { button.textContent = `Á∂ö„Åç„Åã„ÇâË™≠„ÇÄ (${remainingPosts}„É¨„Çπ)`; button.onclick = () => loadMorePosts(button, endChunk + 1); button.disabled = false; } else { button.remove(); }
        } catch(error) { console.error(error); button.textContent = 'Ë™≠„ÅøËæº„ÅøÂ§±Êïó'; } finally { isLoadingPosts = false; }
    };
    
    // --- Bookmark Modal Logic ---
    const updateBookmarkStyle = (postNumber, isBookmarked) => {
        const postEl = document.getElementById(`post-${postNumber}`);
        if(postEl) { postEl.querySelector('.bookmark-icon').textContent = isBookmarked ? 'üîñ' : 'üìé'; postEl.classList.toggle('bookmarked', isBookmarked); }
    };
    window.openBookmarkModal = () => { prepareBookmarkView(null); bookmarkModal.style.display = 'flex'; };
    window.closeBookmarkModal = () => { bookmarkModal.style.display = 'none'; };
    const prepareBookmarkView = (threadId) => {
        bookmarkViewContent.innerHTML = ''; bookmarkViewContent.dataset.currentTid = threadId ?? 'null'; const allBookmarks = BookmarkManager.getAll();
        if (threadId) {
            const threadData = allBookmarks[threadId];
            const title = document.createElement('h3'); title.textContent = `Ê†û: ${escapeHTML(threadData?.title || '‰∏çÊòé„Å™„Çπ„É¨„ÉÉ„Éâ')}`;
            const backBtn = document.createElement('button'); backBtn.className = 'back-button'; backBtn.textContent = '¬´ Ê†û‰∏ÄË¶ß„Å´Êàª„Çã'; backBtn.onclick = () => prepareBookmarkView(null);
            bookmarkViewContent.append(backBtn, title);
            if (threadData && Object.keys(threadData.bookmarks).length > 0) { Object.entries(threadData.bookmarks).sort((a,b) => parseInt(a[0]) - parseInt(b[0])).forEach(([postNumber, bookmark]) => { const item = document.createElement('div'); item.className = 'bookmark-item'; item.innerHTML = `<div style="flex-grow: 1;"><strong>„É¨„Çπ ${postNumber}</strong><div class="post-body">${escapeHTML(bookmark.content)}</div></div><button class="bookmark-delete-btn">ÂâäÈô§</button>`; item.querySelector('.bookmark-delete-btn').onclick = (e) => { e.stopPropagation(); BookmarkManager.removeSingle(threadId, postNumber); updateBookmarkStyle(postNumber, false); prepareBookmarkView(threadId); }; item.onclick = () => jumpToBookmark(threadId, postNumber); bookmarkViewContent.appendChild(item); }); } else { bookmarkViewContent.insertAdjacentHTML('beforeend', '<p>„Åì„ÅÆ„Çπ„É¨„ÉÉ„Éâ„ÅÆÊ†û„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>'); }
        } else {
            const title = document.createElement('h3'); title.textContent = 'Ê†û‰∏ÄË¶ß'; bookmarkViewContent.appendChild(title);
            if (Object.keys(allBookmarks).length > 0) { Object.entries(allBookmarks).forEach(([tid, threadData]) => { const newestBookmark = Object.entries(threadData.bookmarks).sort((a,b) => parseInt(b[0]) - parseInt(a[0]))[0]; if (!newestBookmark) return; const [postNumber, bookmark] = newestBookmark; const summaryContent = escapeHTML(bookmark.content.length > 10 ? bookmark.content.substring(0, 10) + '...' : bookmark.content); const item = document.createElement('div'); item.className = 'bookmark-item'; item.innerHTML = `<div style="flex-grow: 1;"><div><strong>${escapeHTML(threadData.title)}</strong></div><div class="post-summary">„É¨„Çπ ${postNumber} ${summaryContent}</div></div><div style="text-align: right; display: flex; flex-direction: column; gap: 5px;"><button class="view-thread-bookmarks-btn">ÂÖ®‰ª∂Ë°®Á§∫</button><button class="bookmark-delete-btn">ÂÖ®ÂâäÈô§</button></div>`; item.querySelector('.view-thread-bookmarks-btn').onclick = (e) => { e.stopPropagation(); prepareBookmarkView(tid); }; item.querySelector('.bookmark-delete-btn').onclick = (e) => { e.stopPropagation(); if (confirm(`„Äå${threadData.title}„Äç„ÅÆÊ†û„Çí„Åô„Åπ„Å¶ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) { BookmarkManager.removeForThread(tid); prepareBookmarkView(); if(currentState.threadId === tid) { currentState.posts.forEach(p => updateBookmarkStyle(p.post_number, false)); } } }; item.onclick = () => jumpToBookmark(tid, postNumber); bookmarkViewContent.appendChild(item); }); } else { bookmarkViewContent.insertAdjacentHTML('beforeend', '<p>Ê†û„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ</p>'); }
        }
    };
    const jumpToBookmark = (threadId, postNumber) => {
        const autoDelete = autoDeleteBookmarkCheckbox.checked;
        if (autoDelete) { BookmarkManager.removeSingle(threadId, postNumber); if (currentState.threadId === threadId) { updateBookmarkStyle(postNumber, false); } }
        closeBookmarkModal();
        const currentRoute = parsePath();
        const genre = (currentRoute.view === 'threadContent' || currentRoute.view === 'threadList') ? currentRoute.genre : 'unknown';
        history.pushState({ jumpToPostNumber: parseInt(postNumber, 10) }, '', `/${genre}/${threadId}`);
        router();
    };

    // --- Event Handlers & Form Submissions ---
    document.querySelector('header h1 a').onclick = (e) => { e.preventDefault(); navigate('/'); };
    backToHomeBtnHeader.onclick = () => navigate('/');
    backToThreadListBtnHeader.onclick = () => navigate(`/${currentState.genre}`);
    window.addEventListener('popstate', router);
    document.getElementById('new-thread-form').addEventListener('submit', async (e) => {
        e.preventDefault(); const idToken = window.authState.idToken; const headers = { 'Content-Type': 'application/json' }; if (idToken) headers['Authorization'] = `Bearer ${idToken}`; const form = e.target, btn = form.querySelector('button'), genre = form.elements['new-thread-genre'].value; btn.disabled = true;
        try { const res = await fetch('/api/threads', { method: 'POST', headers, body: JSON.stringify({ genre, title: form.elements['new-thread-title'].value, author: form.elements['new-thread-author'].value, body: form.elements['new-thread-body'].value }) }); if (!res.ok) await handleApiError(res); form.reset(); if (window.authState.user) form.elements['new-thread-author'].value = window.authState.user.displayName; await prepareThreadListView(genre); } catch(err) { console.error(err); alert(err.message); } finally { btn.disabled = false; }
    });
    document.getElementById('new-post-form').addEventListener('submit', async (e) => {
        e.preventDefault(); const idToken = window.authState.idToken; const headers = { 'Content-Type': 'application/json' }; if (idToken) headers['Authorization'] = `Bearer ${idToken}`; const form = e.target, btn = form.querySelector('button'), threadId = form.elements['current-thread-id'].value; btn.disabled = true;
        try { const res = await fetch(`/api/threads/${threadId}/posts`, { method: 'POST', headers, body: JSON.stringify({ author: form.elements['new-post-author'].value, body: form.elements['new-post-body'].value }) }); if (!res.ok) await handleApiError(res); form.reset(); if (window.authState.user) form.elements['new-post-author'].value = window.authState.user.displayName; await prepareThreadContentView(threadId); } catch(err) { console.error(err); alert(err.message); } finally { btn.disabled = false; }
    });

    // --- Initial Load ---
    router();
});
</script>
</body>
</html>