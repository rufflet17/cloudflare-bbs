// functions/api/[[path]].ts

// 1. 型定義 (変更なし)
interface Env {
  MY_D1_DATABASE2: D1Database;
}
interface Thread { /* ... */ }
interface Post { /* ... */ }

// Helper to cache a single post
const cachePost = (waitUntil: (promise: Promise<any>) => void, post: Post) => {
    const cache = caches.default;
    // キャッシュキーをAPIパスと一致させる
    const cacheKey = `https://bbs.dev/api/threads/${post.thread_id}/posts/${post.post_number}`;
    const response = new Response(JSON.stringify(post), {
        headers: { 'Content-Type': 'application/json' }
    });
    response.headers.set("Cache-Control", `public, max-age=${86400 * 7}`); // 7日間
    waitUntil(cache.put(cacheKey, response.clone()));
};

// 2. メインハンドラ (ルーティングの追加と変更)
// -----------------------------------------------------------------------------
export const onRequest: PagesFunction<Env> = async (context) => {
  const { request, env, waitUntil } = context;
  const url = new URL(request.url);
  const path = url.pathname;
  const method = request.method;

  try {
    // --- スレッド一覧 ---
    if (method === 'GET' && path === '/api/threads') {
      return await getThreads(env);
    }
    if (method === 'POST' && path === '/api/threads') {
      return await createThread(request, env, waitUntil);
    }
    
    // --- スレッド情報 (メタデータ) ---
    const threadInfoMatch = path.match(/^\/api\/threads\/(\d+)\/info$/);
    if (method === 'GET' && threadInfoMatch) {
        const threadId = parseInt(threadInfoMatch[1], 10);
        return await getThreadInfo(env, threadId);
    }

    // --- 個別の投稿取得 (キャッシュヒット狙い) ---
    const singlePostMatch = path.match(/^\/api\/threads\/(\d+)\/posts\/(\d+)$/);
    if (method === 'GET' && singlePostMatch) {
        const threadId = parseInt(singlePostMatch[1], 10);
        const postNumber = parseInt(singlePostMatch[2], 10);
        return await getSinglePost(env, waitUntil, threadId, postNumber);
    }

    // --- 投稿作成 ---
    const postMatch = path.match(/^\/api\/threads\/(\d+)\/posts$/);
    if (method === 'POST' && postMatch) {
      const threadId = parseInt(postMatch[1], 10);
      return await createPost(request, env, waitUntil, threadId);
    }

    // --- 欠損投稿の取得 (D1から) ---
    if (method === 'POST' && path === '/api/posts/get-missing') {
        return await getMissingPosts(request, env);
    }

    // --- キャッシュ修復依頼 ---
    if (method === 'POST' && path === '/api/internal/request-cache-repair') {
        return await requestCacheRepair(request, env, waitUntil);
    }

    return new Response(JSON.stringify({ error: 'API endpoint not found' }), { status: 404, headers: { 'Content-Type': 'application/json' } });

  } catch (e: any) {
    console.error("API Error:", e);
    const errorResponse = { error: e.message || "An internal server error occurred." };
    return new Response(JSON.stringify(errorResponse), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });
  }
};

// 3. APIロジック (新しい関数を追加)
// -----------------------------------------------------------------------------

async function getThreads(env: Env) { /* 変更なし */ }
async function createThread(request: Request, env: Env, waitUntil: (p: Promise<any>) => void) { /* 投稿キャッシュ処理を追加 */ }

async function getThreadInfo(env: Env, threadId: number): Promise<Response> {
    const threadInfo = await env.MY_D1_DATABASE2.prepare("SELECT * FROM threads WHERE id = ?").bind(threadId).first<Thread>();
    if (!threadInfo) {
      return new Response(JSON.stringify({ error: "Thread not found" }), { status: 404 });
    }
    return new Response(JSON.stringify(threadInfo));
}

async function getSinglePost(env: Env, waitUntil: (p: Promise<any>) => void, threadId: number, postNumber: number): Promise<Response> {
    const cache = caches.default;
    const cacheKey = `https://bbs.dev/api/threads/${threadId}/posts/${postNumber}`;
    const cachedResponse = await cache.match(cacheKey);
    if (cachedResponse) return cachedResponse;
    
    // キャッシュがなければD1から取得し、キャッシュを作成して返す
    const post = await env.MY_D1_DATABASE2.prepare("SELECT * FROM posts WHERE thread_id = ? AND post_number = ?")
        .bind(threadId, postNumber).first<Post>();
    
    if (!post) {
      return new Response(JSON.stringify({ error: "Post not found" }), { status: 404 });
    }
    
    cachePost(waitUntil, post);
    return new Response(JSON.stringify(post));
}

async function getMissingPosts(request: Request, env: Env): Promise<Response> {
    const { threadId, postNumbers } = await request.json<{ threadId: number, postNumbers: number[] }>();
    if (!threadId || !postNumbers || !Array.isArray(postNumbers) || postNumbers.length === 0) {
        return new Response(JSON.stringify({ error: "Invalid request body" }), { status: 400 });
    }
    // 1000件制限
    if (postNumbers.length > 1000) {
      return new Response(JSON.stringify({ error: "Cannot fetch more than 1000 posts at once" }), { status: 400 });
    }
    
    const placeholders = postNumbers.map(() => '?').join(',');
    const query = `SELECT * FROM posts WHERE thread_id = ? AND post_number IN (${placeholders})`;
    const { results } = await env.MY_D1_DATABASE2.prepare(query)
      .bind(threadId, ...postNumbers)
      .all<Post>();

    return new Response(JSON.stringify(results ?? []));
}

async function requestCacheRepair(request: Request, env: Env, waitUntil: (p: Promise<any>) => void): Promise<Response> {
    const { threadId, postNumbers } = await request.json<{ threadId: number, postNumbers: number[] }>();
    if (!threadId || !postNumbers || !Array.isArray(postNumbers) || postNumbers.length === 0) {
        return new Response(JSON.stringify({ error: "Invalid request body" }), { status: 400 });
    }
    // レートリミットはCloudflare側で設定する

    const repairLogic = async () => {
        // キャッシュの事前確認
        const cache = caches.default;
        const trulyMissingNumbers = [];
        for (const num of postNumbers) {
            const cacheKey = `https://bbs.dev/api/threads/${threadId}/posts/${num}`;
            const exists = await cache.match(cacheKey);
            if (!exists) {
                trulyMissingNumbers.push(num);
            }
        }
        
        if (trulyMissingNumbers.length === 0) return;

        // 本当に欠損しているものだけをD1から取得してキャッシュ
        const placeholders = trulyMissingNumbers.map(() => '?').join(',');
        const query = `SELECT * FROM posts WHERE thread_id = ? AND post_number IN (${placeholders})`;
        const { results } = await env.MY_D1_DATABASE2.prepare(query)
            .bind(threadId, ...trulyMissingNumbers)
            .all<Post>();

        if (results) {
            results.forEach(post => cachePost(waitUntil, post));
        }
    };
    
    waitUntil(repairLogic());
    
    return new Response(JSON.stringify({ success: true, message: "Cache repair job accepted." }), { status: 202 });
}

// createPost関数は、投稿後にその投稿をキャッシュする処理を追加する
async function createPost(request: Request, env: Env, waitUntil: (p: Promise<any>) => void, threadId: number): Promise<Response> {
    const { author, body } = await request.json<{ author: string, body: string }>();
    if (!body) return new Response(JSON.stringify({ error: "Body is required" }), { status: 400 });

    const [updateResult] = await env.MY_D1_DATABASE2.batch([
      env.MY_D1_DATABASE2.prepare("UPDATE threads SET post_count = post_count + 1, last_updated = CURRENT_TIMESTAMP WHERE id = ? RETURNING post_count").bind(threadId)
    ]);
    const newPostCount = updateResult.results[0].post_count as number;
    
    const newPost = await env.MY_D1_DATABASE2.prepare("INSERT INTO posts (thread_id, post_number, author, body) VALUES (?, ?, ?, ?) RETURNING *")
        .bind(threadId, newPostCount, author || '名無しさん', body)
        .first<Post>();
    
    if (newPost) {
        cachePost(waitUntil, newPost);
    }

    return new Response(JSON.stringify({ success: true, postCount: newPostCount }), { status: 201 });
}

// createThread関数も同様
async function createThread(request: Request, env: Env, waitUntil: (p: Promise<any>) => void): Promise<Response> {
    const { title, author, body } = await request.json<{ title: string, author: string, body: string }>();
    if (!title || !body) return new Response(JSON.stringify({ error: "Title and body are required" }), { status: 400 });

    const threadResult = await env.MY_D1_DATABASE2.prepare("INSERT INTO threads (title) VALUES (?) RETURNING id").bind(title).first<{id: number}>();
    if (!threadResult || !threadResult.id) throw new Error("Failed to create thread");
    const newThreadId = threadResult.id;

    const firstPost = await env.MY_D1_DATABASE2.prepare("INSERT INTO posts (thread_id, post_number, author, body) VALUES (?, 1, ?, ?) RETURNING *")
        .bind(newThreadId, author || '名無しさん', body)
        .first<Post>();

    if(firstPost){
        cachePost(waitUntil, firstPost);
    }
    
    return new Response(JSON.stringify({ id: newThreadId }), { status: 201 });
}